"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask";
exports.ids = ["vendor-chunks/@metamask"];
exports.modules = {

/***/ "(ssr)/./node_modules/@metamask/safe-event-emitter/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/safe-event-emitter/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    } catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(()=>{\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for(let i = 0; i < n; i += 1){\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === \"error\";\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        } else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === \"function\") {\n            safeApply(handler, this, args);\n        } else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for(let i = 0; i < len; i += 1){\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports[\"default\"] = SafeEventEmitter; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxTQUFTQyxVQUFVQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsSUFBSTtJQUNyQyxJQUFJO1FBQ0FDLFFBQVFDLEtBQUssQ0FBQ0osU0FBU0MsU0FBU0M7SUFDcEMsRUFDQSxPQUFPRyxLQUFLO1FBQ1IsNkRBQTZEO1FBQzdEQyxXQUFXO1lBQ1AsTUFBTUQ7UUFDVjtJQUNKO0FBQ0o7QUFDQSxTQUFTRSxXQUFXQyxHQUFHO0lBQ25CLE1BQU1DLElBQUlELElBQUlFLE1BQU07SUFDcEIsTUFBTUMsT0FBTyxJQUFJQyxNQUFNSDtJQUN2QixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUosR0FBR0ksS0FBSyxFQUFHO1FBQzNCRixJQUFJLENBQUNFLEVBQUUsR0FBR0wsR0FBRyxDQUFDSyxFQUFFO0lBQ3BCO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBLE1BQU1HLHlCQUF5QmpCLFNBQVNrQixZQUFZO0lBQ2hEQyxLQUFLQyxJQUFJLEVBQUUsR0FBR2YsSUFBSSxFQUFFO1FBQ2hCLElBQUlnQixVQUFVRCxTQUFTO1FBQ3ZCLE1BQU1FLFNBQVMsSUFBSSxDQUFDQyxPQUFPO1FBQzNCLElBQUlELFdBQVdFLFdBQVc7WUFDdEJILFVBQVVBLFdBQVdDLE9BQU9HLEtBQUssS0FBS0Q7UUFDMUMsT0FDSyxJQUFJLENBQUNILFNBQVM7WUFDZixPQUFPO1FBQ1g7UUFDQSxvREFBb0Q7UUFDcEQsSUFBSUEsU0FBUztZQUNULElBQUlLO1lBQ0osSUFBSXJCLEtBQUtRLE1BQU0sR0FBRyxHQUFHO2dCQUNqQixDQUFDYSxHQUFHLEdBQUdyQjtZQUNYO1lBQ0EsSUFBSXFCLGNBQWNDLE9BQU87Z0JBQ3JCLHFFQUFxRTtnQkFDckUsaUVBQWlFO2dCQUNqRSxNQUFNRCxJQUFJLDBCQUEwQjtZQUN4QztZQUNBLGlEQUFpRDtZQUNqRCxNQUFNbEIsTUFBTSxJQUFJbUIsTUFBTSxDQUFDLGdCQUFnQixFQUFFRCxLQUFLLENBQUMsRUFBRSxFQUFFQSxHQUFHRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3ZFcEIsSUFBSUosT0FBTyxHQUFHc0I7WUFDZCxNQUFNbEIsS0FBSywwQkFBMEI7UUFDekM7UUFDQSxNQUFNTCxVQUFVbUIsTUFBTSxDQUFDRixLQUFLO1FBQzVCLElBQUlqQixZQUFZcUIsV0FBVztZQUN2QixPQUFPO1FBQ1g7UUFDQSxJQUFJLE9BQU9yQixZQUFZLFlBQVk7WUFDL0JELFVBQVVDLFNBQVMsSUFBSSxFQUFFRTtRQUM3QixPQUNLO1lBQ0QsTUFBTXdCLE1BQU0xQixRQUFRVSxNQUFNO1lBQzFCLE1BQU1pQixZQUFZcEIsV0FBV1A7WUFDN0IsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUlhLEtBQUtiLEtBQUssRUFBRztnQkFDN0JkLFVBQVU0QixTQUFTLENBQUNkLEVBQUUsRUFBRSxJQUFJLEVBQUVYO1lBQ2xDO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBUCxrQkFBZSxHQUFHbUIsa0JBQ2xCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyL2luZGV4LmpzPzY4ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5mdW5jdGlvbiBzYWZlQXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIFJlZmxlY3QuYXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIpIHtcbiAgICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgICBjb25zdCBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuY2xhc3MgU2FmZUV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZW1pdCh0eXBlLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgICAgICBpZiAoZG9FcnJvcikge1xuICAgICAgICAgICAgbGV0IGVyO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIFtlcl0gPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgICAgICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBVbmhhbmRsZWQgZXJyb3IuJHtlciA/IGAgKCR7ZXIubWVzc2FnZX0pYCA6ICcnfWApO1xuICAgICAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlQXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgc2FmZUFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2FmZUV2ZW50RW1pdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV2ZW50c18xIiwicmVxdWlyZSIsInNhZmVBcHBseSIsImhhbmRsZXIiLCJjb250ZXh0IiwiYXJncyIsIlJlZmxlY3QiLCJhcHBseSIsImVyciIsInNldFRpbWVvdXQiLCJhcnJheUNsb25lIiwiYXJyIiwibiIsImxlbmd0aCIsImNvcHkiLCJBcnJheSIsImkiLCJTYWZlRXZlbnRFbWl0dGVyIiwiRXZlbnRFbWl0dGVyIiwiZW1pdCIsInR5cGUiLCJkb0Vycm9yIiwiZXZlbnRzIiwiX2V2ZW50cyIsInVuZGVmaW5lZCIsImVycm9yIiwiZXIiLCJFcnJvciIsIm1lc3NhZ2UiLCJsZW4iLCJsaXN0ZW5lcnMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/safe-event-emitter/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/assert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/assert.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns True or false, depending on the result.\n */ function isErrorWithMessage(error) {\n    return typeof error === \"object\" && error !== null && \"message\" in error;\n}\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */ function isConstructable(fn) {\n    var _a, _b;\n    /* istanbul ignore next */ return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === \"string\");\n}\n/**\n * Get the error message from an unknown error object. If the error object has\n * a `message` property, that property is returned. Otherwise, the stringified\n * error object is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The error message.\n */ function getErrorMessage(error) {\n    const message = isErrorWithMessage(error) ? error.message : String(error);\n    // If the error ends with a period, remove it, as we'll add our own period.\n    if (message.endsWith(\".\")) {\n        return message.slice(0, -1);\n    }\n    return message;\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message\n        });\n    }\n    return ErrorWrapper({\n        message\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */ class AssertionError extends Error {\n    constructor(options){\n        super(options.message);\n        this.code = \"ERR_ASSERTION\";\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */ function assert(value, message = \"Assertion failed.\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */ function assertStruct(value, struct, errorPrefix = \"Assertion failed\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    } catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */ function assertExhaustive(_object) {\n    throw new Error(\"Invalid branch reached. Should be detected during compilation.\");\n}\nexports.assertExhaustive = assertExhaustive; //# sourceMappingURL=assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLGNBQWMsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUNqRyxNQUFNTSxnQkFBZ0JDLG1CQUFPQSxDQUFDLGlHQUFhO0FBQzNDOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLG1CQUFtQkMsS0FBSztJQUM3QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLGFBQWFBO0FBQ3ZFO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsZ0JBQWdCQyxFQUFFO0lBQ3ZCLElBQUlDLElBQUlDO0lBQ1Isd0JBQXdCLEdBQ3hCLE9BQU9DLFFBQVEsT0FBUSxFQUFDRCxLQUFLLENBQUNELEtBQUtELE9BQU8sUUFBUUEsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxTQUFTLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxXQUFXLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxJQUFJLE1BQU07QUFDcE07QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsZ0JBQWdCVCxLQUFLO0lBQzFCLE1BQU1VLFVBQVVYLG1CQUFtQkMsU0FBU0EsTUFBTVUsT0FBTyxHQUFHQyxPQUFPWDtJQUNuRSwyRUFBMkU7SUFDM0UsSUFBSVUsUUFBUUUsUUFBUSxDQUFDLE1BQU07UUFDdkIsT0FBT0YsUUFBUUcsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUM3QjtJQUNBLE9BQU9IO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDRCxnRUFBZ0U7QUFDaEUsU0FBU0ksU0FBU0MsWUFBWSxFQUFFTCxPQUFPO0lBQ25DLElBQUlULGdCQUFnQmMsZUFBZTtRQUMvQixPQUFPLElBQUlBLGFBQWE7WUFDcEJMO1FBQ0o7SUFDSjtJQUNBLE9BQU9LLGFBQWE7UUFDaEJMO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWQsdUJBQXVCb0I7SUFDekJULFlBQVlVLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFFBQVFQLE9BQU87UUFDckIsSUFBSSxDQUFDUSxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNBM0Isc0JBQXNCLEdBQUdLO0FBQ3pCOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0QsT0FBT0gsS0FBSyxFQUFFa0IsVUFBVSxtQkFBbUIsRUFDcEQsZ0VBQWdFO0FBQ2hFSyxlQUFlbkIsY0FBYztJQUN6QixJQUFJLENBQUNKLE9BQU87UUFDUixJQUFJa0IsbUJBQW1CTSxPQUFPO1lBQzFCLE1BQU1OO1FBQ1Y7UUFDQSxNQUFNSSxTQUFTQyxjQUFjTDtJQUNqQztBQUNKO0FBQ0FuQixjQUFjLEdBQUdJO0FBQ2pCOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTRCxhQUFhRixLQUFLLEVBQUUyQixNQUFNLEVBQUVDLGNBQWMsa0JBQWtCLEVBQ3JFLGdFQUFnRTtBQUNoRUwsZUFBZW5CLGNBQWM7SUFDekIsSUFBSTtRQUNDLElBQUdDLGNBQWNGLE1BQU0sRUFBRUgsT0FBTzJCO0lBQ3JDLEVBQ0EsT0FBT25CLE9BQU87UUFDVixNQUFNYyxTQUFTQyxjQUFjLENBQUMsRUFBRUssWUFBWSxFQUFFLEVBQUVYLGdCQUFnQlQsT0FBTyxDQUFDLENBQUM7SUFDN0U7QUFDSjtBQUNBVCxvQkFBb0IsR0FBR0c7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNELGlCQUFpQjRCLE9BQU87SUFDN0IsTUFBTSxJQUFJTCxNQUFNO0FBQ3BCO0FBQ0F6Qix3QkFBd0IsR0FBR0Usa0JBQzNCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9hc3NlcnQuanM/ZjdjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLkFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYG1lc3NhZ2VgIHByb3BlcnR5LCBzdWNoIGFzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ21lc3NhZ2UnIGluIGVycm9yO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIGkuZS4sIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHdpdGhcbiAqIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBjb25zdHJ1Y3Rvciwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ29uc3RydWN0YWJsZShmbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgKChfYiA9IChfYSA9IGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbi5wcm90b3R5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIHVua25vd24gZXJyb3Igb2JqZWN0LiBJZiB0aGUgZXJyb3Igb2JqZWN0IGhhc1xuICogYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoYXQgcHJvcGVydHkgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIHN0cmluZ2lmaWVkXG4gKiBlcnJvciBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgIC8vIElmIHRoZSBlcnJvciBlbmRzIHdpdGggYSBwZXJpb2QsIHJlbW92ZSBpdCwgYXMgd2UnbGwgYWRkIG91ciBvd24gcGVyaW9kLlxuICAgIGlmIChtZXNzYWdlLmVuZHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogSW5pdGlhbGlzZSBhbiB7QGxpbmsgQXNzZXJ0aW9uRXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3IuXG4gKlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKSB7XG4gICAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgY2xhc3MgdGhhdCBpcyB0aHJvd24gaWYgYW4gYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICB9XG59XG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG4vKipcbiAqIFNhbWUgYXMgTm9kZS5qcyBhc3NlcnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgZmFsc3ksIHRocm93cyBhbiBlcnJvciwgZG9lcyBub3RoaW5nIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBBc3NlcnRpb25FcnJvcn0gSWYgdmFsdWUgaXMgZmFsc3kuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdGVzdCB0aGF0IHNob3VsZCBiZSB0cnV0aHkgdG8gcGFzcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gTWVzc2FnZSB0byBiZSBwYXNzZWQgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfSBvciBhblxuICoge0BsaW5rIEVycm9yfSBpbnN0YW5jZSB0byB0aHJvdy5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uIElmIGEgY3VzdG9tIGVycm9yIGNsYXNzIGlzIHByb3ZpZGVkIGZvclxuICogdGhlIGBtZXNzYWdlYCBhcmd1bWVudCwgdGhpcyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIEFzc2VydCBhIHZhbHVlIGFnYWluc3QgYSBTdXBlcnN0cnVjdCBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBlcnJvclByZWZpeCAtIEEgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgbWVzc2FnZS4gRGVmYXVsdHMgdG9cbiAqIFwiQXNzZXJ0aW9uIGZhaWxlZFwiLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3RydWN0KHZhbHVlLCBzdHJ1Y3QsIGVycm9yUHJlZml4ID0gJ0Fzc2VydGlvbiBmYWlsZWQnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHN1cGVyc3RydWN0XzEuYXNzZXJ0KSh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZShlcnJvcil9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gYXNzZXJ0U3RydWN0O1xuLyoqXG4gKiBVc2UgaW4gdGhlIGRlZmF1bHQgY2FzZSBvZiBhIHN3aXRjaCB0aGF0IHlvdSB3YW50IHRvIGJlIGZ1bGx5IGV4aGF1c3RpdmUuXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIGZvcmNlcyB0aGUgY29tcGlsZXIgdG8gZW5mb3JjZSBleGhhdXN0aXZpdHkgZHVyaW5nXG4gKiBjb21waWxlLXRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgbnVtYmVyID0gMTtcbiAqIHN3aXRjaCAobnVtYmVyKSB7XG4gKiAgIGNhc2UgMDpcbiAqICAgICAuLi5cbiAqICAgY2FzZSAxOlxuICogICAgIC4uLlxuICogICBkZWZhdWx0OlxuICogICAgIGFzc2VydEV4aGF1c3RpdmUoc25hcFByZWZpeCk7XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBfb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0aGUgc3dpdGNoIGlzIGJlaW5nIG9wZXJhdGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFeGhhdXN0aXZlKF9vYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uJyk7XG59XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBhc3NlcnRFeGhhdXN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFzc2VydEV4aGF1c3RpdmUiLCJhc3NlcnRTdHJ1Y3QiLCJhc3NlcnQiLCJBc3NlcnRpb25FcnJvciIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiaXNFcnJvcldpdGhNZXNzYWdlIiwiZXJyb3IiLCJpc0NvbnN0cnVjdGFibGUiLCJmbiIsIl9hIiwiX2IiLCJCb29sZWFuIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZ2V0RXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsIlN0cmluZyIsImVuZHNXaXRoIiwic2xpY2UiLCJnZXRFcnJvciIsIkVycm9yV3JhcHBlciIsIkVycm9yIiwib3B0aW9ucyIsImNvZGUiLCJzdHJ1Y3QiLCJlcnJvclByZWZpeCIsIl9vYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/base64.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/base64.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */ const base64 = (struct, options = {})=>{\n    var _a, _b;\n    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;\n    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : \"base64\";\n    let letters;\n    if (characterSet === \"base64\") {\n        letters = String.raw`[A-Za-z0-9+\\/]`;\n    } else {\n        (0, assert_1.assert)(characterSet === \"base64url\");\n        letters = String.raw`[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    } else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64; //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGlHQUFhO0FBQzNDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLHFFQUFVO0FBQ25DOzs7Ozs7Q0FNQyxHQUNELE1BQU1GLFNBQVMsQ0FBQ0ksUUFBUUMsVUFBVSxDQUFDLENBQUM7SUFDaEMsSUFBSUMsSUFBSUM7SUFDUixNQUFNQyxrQkFBa0IsQ0FBQ0YsS0FBS0QsUUFBUUcsZUFBZSxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQ3hGLE1BQU1HLGVBQWUsQ0FBQ0YsS0FBS0YsUUFBUUksWUFBWSxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQ2xGLElBQUlHO0lBQ0osSUFBSUQsaUJBQWlCLFVBQVU7UUFDM0JDLFVBQVVDLE9BQU9DLEdBQUcsQ0FBRSxjQUFjLENBQUM7SUFDekMsT0FDSztRQUNBLElBQUdULFNBQVNVLE1BQU0sRUFBRUosaUJBQWlCO1FBQ3RDQyxVQUFVQyxPQUFPQyxHQUFHLENBQUUsYUFBYSxDQUFDO0lBQ3hDO0lBQ0EsSUFBSUU7SUFDSixJQUFJTixpQkFBaUI7UUFDakJNLEtBQUssSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUwsUUFBUSxRQUFRLEVBQUVBLFFBQVEsS0FBSyxFQUFFQSxRQUFRLFFBQVEsQ0FBQyxFQUFFO0lBQy9FLE9BQ0s7UUFDREksS0FBSyxJQUFJQyxPQUFPLENBQUMsSUFBSSxFQUFFTCxRQUFRLFFBQVEsRUFBRUEsUUFBUSxNQUFNLEVBQUVBLFFBQVEsS0FBSyxFQUFFQSxRQUFRLFFBQVEsQ0FBQyxFQUFFO0lBQy9GO0lBQ0EsT0FBTyxDQUFDLEdBQUdULGNBQWNlLE9BQU8sRUFBRVosUUFBUVU7QUFDOUM7QUFDQWhCLGNBQWMsR0FBR0UsUUFDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5qcz9jMjhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjQgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gKF9hID0gb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IChfYiA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYmFzZTY0JztcbiAgICBsZXQgbGV0dGVycztcbiAgICBpZiAoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgW0EtWmEtejAtOStcXC9dYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NHVybCcpO1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgWy1fQS1aYS16MC05XWA7XG4gICAgfVxuICAgIGxldCByZTtcbiAgICBpZiAocGFkZGluZ1JlcXVpcmVkKSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezIsM318JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKHN0cnVjdCwgcmUpO1xufTtcbmV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJhc2U2NCIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJzdHJ1Y3QiLCJvcHRpb25zIiwiX2EiLCJfYiIsInBhZGRpbmdSZXF1aXJlZCIsImNoYXJhY3RlclNldCIsImxldHRlcnMiLCJTdHJpbmciLCJyYXciLCJhc3NlcnQiLCJyZSIsIlJlZ0V4cCIsInBhdHRlcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/bytes.js":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/bytes.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.js\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */ function getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return ()=>{\n        if (lookupTable.length === 0) {\n            for(let i = 0; i < 256; i++){\n                lookupTable.push(i.toString(16).padStart(2, \"0\"));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */ const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */ function isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */ function assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), \"Value must be a Uint8Array.\");\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */ function bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return \"0x\";\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(\"\"));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */ function bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */ function bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes){\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */ function bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), \"Number is not a safe integer. Use `bytesToBigInt` instead.\");\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */ function bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function hexToBytes(value) {\n    var _a;\n    // \"0x\" is often used as empty byte array.\n    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === \"0x\") {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for(let i = 0; i < bytes.length; i++){\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= BigInt(0), \"Value must be a non-negative bigint.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */ function bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */ const mask = value >> BigInt(31);\n    return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));\n/* eslint-enable no-bitwise */ }\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */ function signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(typeof byteLength === \"number\", \"Byte length must be a number.\");\n    (0, assert_1.assert)(byteLength > 0, \"Byte length must be greater than 0.\");\n    (0, assert_1.assert)(bigIntFits(value, byteLength), \"Byte length is too small to represent the given value.\");\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */ function numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToBytes` instead.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"string\", \"Value must be a string.\");\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function valueToBytes(value) {\n    if (typeof value === \"bigint\") {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === \"number\") {\n        return numberToBytes(value);\n    }\n    if (typeof value === \"string\") {\n        if (value.startsWith(\"0x\")) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */ function concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for(let i = 0; i < values.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0, offset = 0; i < normalizedValues.length; i++){\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */ function createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== \"undefined\" && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLHFCQUFxQixHQUFHQSwyQkFBMkIsR0FBR0EscUJBQXFCLEdBQUdBLGtCQUFrQixHQUFHQSxxQkFBcUIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDM1csTUFBTWlCLFdBQVdDLG1CQUFPQSxDQUFDLHFFQUFVO0FBQ25DLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLCtEQUFPO0FBQzdCLDJCQUEyQjtBQUMzQixNQUFNRSwrQkFBK0I7QUFDckMsMkJBQTJCO0FBQzNCLE1BQU1DLCtCQUErQjtBQUNyQyxNQUFNQyx1QkFBdUI7QUFDN0I7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNDO0lBQ0wsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsZUFBZTtJQUNmLE1BQU1DLGNBQWMsRUFBRTtJQUN0QixPQUFPO1FBQ0gsSUFBSUEsWUFBWUMsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztnQkFDMUJGLFlBQVlHLElBQUksQ0FBQ0QsRUFBRUUsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO1lBQ2hEO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCxNQUFNTSwwQkFBMEJQO0FBQ2hDOzs7OztDQUtDLEdBQ0QsU0FBU1AsUUFBUWYsS0FBSztJQUNsQixPQUFPQSxpQkFBaUI4QjtBQUM1QjtBQUNBL0IsZUFBZSxHQUFHZ0I7QUFDbEI7Ozs7O0NB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LFFBQVE7UUFDMUQsTUFBTUMsU0FBU3pDLE1BQU15QyxNQUFNLENBQUNDLEtBQUssQ0FBQzFDLE1BQU0yQyxVQUFVLEVBQUUzQyxNQUFNMkMsVUFBVSxHQUFHM0MsTUFBTTJCLFVBQVU7UUFDdkYsT0FBTyxJQUFJaUIsU0FBU0g7SUFDeEI7SUFDQSxPQUFPLElBQUlHLFNBQVM1QyxNQUFNeUMsTUFBTSxFQUFFekMsTUFBTTJDLFVBQVUsRUFBRTNDLE1BQU0yQixVQUFVO0FBQ3hFO0FBQ0E1RCxzQkFBc0IsR0FBR0UsZ0JBQ3pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5qcz8wMjdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnZhbHVlVG9CeXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IGV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGV4cG9ydHMuaXNCeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vLyAnMCcuY2hhckNvZGVBdCgwKSA9PT0gNDhcbmNvbnN0IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVIgPSA0ODtcbi8vICc5Jy5jaGFyQ29kZUF0KDApID09PSA1N1xuY29uc3QgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDU4O1xuY29uc3QgSEVYX0NIQVJBQ1RFUl9PRkZTRVQgPSA4Nztcbi8qKlxuICogTWVtb2l6ZWQgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IHRvIGJlIHVzZWQgYXMgYSBsb29rdXAgdGFibGUgZm9yXG4gKiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleGFkZWNpbWFsIHZhbHVlcy5cbiAqXG4gKiBUaGUgYXJyYXkgaXMgY3JlYXRlZCBsYXppbHkgYW5kIHRoZW4gY2FjaGVkIGZvciBmdXR1cmUgdXNlLiBUaGUgYmVuZWZpdCBvZlxuICogdGhpcyBhcHByb2FjaCBpcyB0aGF0IHRoZSBwZXJmb3JtYW5jZSBvZiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleCBpcyBtdWNoXG4gKiBiZXR0ZXIgdGhhbiBpZiB3ZSB3ZXJlIHRvIGNhbGwgYHRvU3RyaW5nKDE2KWAgb24gZWFjaCBieXRlLlxuICpcbiAqIFRoZSBkb3duc2lkZSBpcyB0aGF0IHRoZSBhcnJheSBpcyBjcmVhdGVkIG9uY2UgYW5kIHRoZW4gbmV2ZXIgZ2FyYmFnZVxuICogY29sbGVjdGVkLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gaW4gcHJhY3RpY2UgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSAyNTZcbiAqIGVsZW1lbnRzIGxvbmcuXG4gKlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0YWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCkge1xuICAgIC8vIFRvIGF2b2lkIGlzc3VlcyB3aXRoIHRyZWUgc2hha2luZywgd2UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gdGhlXG4gICAgLy8gYXJyYXkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSB1c2VkIGluIHRoZSBgYnl0ZXNUb0hleGAgZnVuY3Rpb25cbiAgICAvLyBhbmQgaWYgd2Ugd2VyZSB0byB1c2UgYSBnbG9iYWwgdmFyaWFibGUsIHRoZSBhcnJheSBtaWdodCBiZSByZW1vdmVkIGJ5IHRoZVxuICAgIC8vIHRyZWUgc2hha2VyLlxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gW107XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlLnB1c2goaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvb2t1cFRhYmxlO1xuICAgIH07XG59XG4vKipcbiAqIEZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyfVxuICogZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCk7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0J5dGVzKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBVaW50OEFycmF5LicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gYXNzZXJ0SXNCeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzKCk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBuZXcgQXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGhleGFkZWNpbWFsW2ldID0gbG9va3VwVGFibGVbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KShoZXhhZGVjaW1hbC5qb2luKCcnKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb051bWJlcn0uXG4gKiBUbyBjb252ZXJ0IGEgdHdvJ3MgY29tcGxlbWVudCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLCB1c2VcbiAqIHtAbGluayBieXRlc1RvU2lnbmVkQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBieXRlc1RvSGV4KGJ5dGVzKTtcbiAgICByZXR1cm4gQmlnSW50KGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGJ5dGVzVG9CaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBzaWduZWQgYGJpZ2ludGAuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBieXRlcyBhcmVcbiAqIGVuY29kZWQgaW4gdHdvJ3MgY29tcGxlbWVudC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGFuIHVuc2lnbmVkIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHNpZ25lZCBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBzaWduZWQgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TaWduZWRCaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBsZXQgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIDw8IEJpZ0ludCg4KSkgKyBCaWdJbnQoYnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGJ5dGVzLmxlbmd0aCAqIDgsIHZhbHVlKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGJ5dGVzVG9TaWduZWRCaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGJpZ2ludCA9IGJ5dGVzVG9CaWdJbnQoYnl0ZXMpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ2ludCA8PSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCAnTnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBieXRlc1RvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBOdW1iZXIoYmlnaW50KTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGJ5dGVzVG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBzdHJpbmdgLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBVaW50OEFycmF5YC4gVGhlIHN0cmluZyBjYW4gb3B0aW9uYWxseSBiZVxuICogcHJlZml4ZWQgd2l0aCBgMHhgLiBJdCBhY2NlcHRzIGV2ZW4gYW5kIG9kZCBsZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgXCIweFwiLCBhbiBlbXB0eSBgVWludDhBcnJheWAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICgoKF9hID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvTG93ZXJDYXNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZSkpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZS1saWtlIHZhbHVlIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWUgY2FuIGJlIGEgYFVpbnQ4QXJyYXlgLFxuICogYSBgYmlnaW50YCwgYSBgbnVtYmVyYCwgb3IgYSBgc3RyaW5nYC5cbiAqXG4gKiBUaGlzIHdpbGwgYXR0ZW1wdCB0byBndWVzcyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmFzZWQgb24gaXRzIHR5cGUgYW5kXG4gKiBjb250ZW50cy4gRm9yIG1vcmUgY29udHJvbCBvdmVyIHRoZSBjb252ZXJzaW9uLCB1c2UgdGhlIG1vcmUgc3BlY2lmaWNcbiAqIGNvbnZlcnNpb24gZnVuY3Rpb25zLCBzdWNoIGFzIHtAbGluayBoZXhUb0J5dGVzfSBvciB7QGxpbmsgc3RyaW5nVG9CeXRlc30uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYHN0cmluZ2AsIGFuZCBpdCBpcyBwcmVmaXhlZCB3aXRoIGAweGAsIGl0IHdpbGwgYmVcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICogVVRGLTggc3RyaW5nLiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGJ5dGVzIHdpdGhvdXQgaW50ZXJwcmV0aW5nXG4gKiBpdCBhcyBhIFVURi04IHN0cmluZywgdXNlIHtAbGluayBoZXhUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBhc3N1bWVkIHRvIGJlIHVuc2lnbmVkLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCB0byBieXRlcywgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHZhbHVlVG9CeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBiaWdJbnRUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWUgdHlwZTogXCIke3R5cGVvZiB2YWx1ZX1cIi5gKTtcbn1cbmV4cG9ydHMudmFsdWVUb0J5dGVzID0gdmFsdWVUb0J5dGVzO1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBtdWx0aXBsZSBieXRlLWxpa2UgdmFsdWVzIGludG8gYSBzaW5nbGUgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWVzXG4gKiBjYW4gYmUgYFVpbnQ4QXJyYXlgLCBgYmlnaW50YCwgYG51bWJlcmAsIG9yIGBzdHJpbmdgLiBUaGlzIHVzZXNcbiAqIHtAbGluayB2YWx1ZVRvQnl0ZXN9IHVuZGVyIHRoZSBob29kIHRvIGNvbnZlcnQgZWFjaCB2YWx1ZSB0byBieXRlcy4gUmVmZXIgdG9cbiAqIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXModmFsdWVzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBsZXQgYnl0ZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVRvQnl0ZXModmFsdWVzW2ldKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgICBieXRlTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IG5vcm1hbGl6ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgd2UgY291bGQgc2ltcGx5IHNwcmVhZCB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkgYW5kIHVzZVxuICAgICAgICAvLyBgVWludDhBcnJheS5mcm9tYCwgdGhhdCBpcyBhIGxvdCBzbG93ZXIgdGhhbiB1c2luZyBgVWludDhBcnJheS5zZXRgLlxuICAgICAgICBieXRlcy5zZXQobm9ybWFsaXplZFZhbHVlc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IG5vcm1hbGl6ZWRWYWx1ZXNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gZnJvbSBhIHtAbGluayBVaW50OEFycmF5fS4gVGhpcyBpcyBhIGNvbnZlbmllbmNlXG4gKiBmdW5jdGlvbiB0aGF0IGF2b2lkcyBoYXZpbmcgdG8gY3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBtYW51YWxseSwgd2hpY2hcbiAqIHJlcXVpcmVzIHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgZXZlcnkgdGltZS5cbiAqXG4gKiBOb3QgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBjYW4gcmVzdWx0IGluXG4gKiB1bmV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIHtAbGluayBVaW50OEFycmF5fSBpcyBhIHZpZXcgb2YgYSBsYXJnZXJcbiAqIHtAbGluayBBcnJheUJ1ZmZlcn0sIGUuZy4sIHdoZW4gdXNpbmcge0BsaW5rIFVpbnQ4QXJyYXkuc3ViYXJyYXl9LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBzdXBwb3J0cyBOb2RlLmpzIHtAbGluayBCdWZmZXJ9cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMiwgM10pO1xuICpcbiAqIC8vIFRoaXMgaXMgZXF1aXZhbGVudCB0bzpcbiAqIC8vIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gKiBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3KGJ5dGVzKTtcbiAqIGBgYFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNyZWF0ZSB0aGUge0BsaW5rIERhdGFWaWV3fSBmcm9tLlxuICogQHJldHVybnMgVGhlIHtAbGluayBEYXRhVmlld30uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3KGJ5dGVzKSB7XG4gICAgLy8gVG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIE5vZGUuanMsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGJ5dGVzIGFyZVxuICAgIC8vIGEgQnVmZmVyLiBJZiBzbywgd2UgbmVlZCB0byBzbGljZSB0aGUgYnVmZmVyIHRvIGdldCB0aGUgdW5kZXJseWluZ1xuICAgIC8vIEFycmF5QnVmZmVyLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnl0ZXMuYnVmZmVyLnNsaWNlKGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVPZmZzZXQgKyBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG59XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVEYXRhVmlldyIsImNvbmNhdEJ5dGVzIiwidmFsdWVUb0J5dGVzIiwic3RyaW5nVG9CeXRlcyIsIm51bWJlclRvQnl0ZXMiLCJzaWduZWRCaWdJbnRUb0J5dGVzIiwiYmlnSW50VG9CeXRlcyIsImhleFRvQnl0ZXMiLCJieXRlc1RvU3RyaW5nIiwiYnl0ZXNUb051bWJlciIsImJ5dGVzVG9TaWduZWRCaWdJbnQiLCJieXRlc1RvQmlnSW50IiwiYnl0ZXNUb0hleCIsImFzc2VydElzQnl0ZXMiLCJpc0J5dGVzIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiaGV4XzEiLCJIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSIiwiSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiIsIkhFWF9DSEFSQUNURVJfT0ZGU0VUIiwiZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyIiwibG9va3VwVGFibGUiLCJsZW5ndGgiLCJpIiwicHVzaCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJnZXRQcmVjb21wdXRlZEhleFZhbHVlcyIsIlVpbnQ4QXJyYXkiLCJhc3NlcnQiLCJieXRlcyIsImhleGFkZWNpbWFsIiwiQXJyYXkiLCJhZGQweCIsImpvaW4iLCJCaWdJbnQiLCJieXRlIiwiYXNJbnROIiwiYmlnaW50IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiX2EiLCJ0b0xvd2VyQ2FzZSIsImNhbGwiLCJhc3NlcnRJc0hleFN0cmluZyIsInN0cmlwcGVkVmFsdWUiLCJyZW1vdmUweCIsIm5vcm1hbGl6ZWRWYWx1ZSIsImMxIiwiY2hhckNvZGVBdCIsImMyIiwibjEiLCJuMiIsImJpZ0ludEZpdHMiLCJtYXNrIiwiYnl0ZUxlbmd0aCIsIm51bWJlclZhbHVlIiwiYXNVaW50TiIsInJldmVyc2UiLCJpc1NhZmVJbnRlZ2VyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJzdGFydHNXaXRoIiwiVHlwZUVycm9yIiwidmFsdWVzIiwibm9ybWFsaXplZFZhbHVlcyIsIm9mZnNldCIsInNldCIsIkJ1ZmZlciIsImJ1ZmZlciIsInNsaWNlIiwiYnl0ZU9mZnNldCIsIkRhdGFWaWV3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/checksum.js":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/checksum.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\nconst base64_1 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/@metamask/utils/dist/base64.js\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), {\n    paddingRequired: true\n}), 44, 44); //# sourceMappingURL=checksum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHLEtBQUs7QUFDOUIsTUFBTUcsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxpR0FBYTtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxxRUFBVTtBQUNuQ0osc0JBQXNCLEdBQUcsQ0FBQyxHQUFHRyxjQUFjRyxJQUFJLEVBQUUsQ0FBQyxHQUFHRCxTQUFTRSxNQUFNLEVBQUUsQ0FBQyxHQUFHSixjQUFjSyxNQUFNLEtBQUs7SUFBRUMsaUJBQWlCO0FBQUssSUFBSSxJQUFJLEtBQ25JLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaGVja3N1bS5qcz81ZmFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5zaXplKSgoMCwgYmFzZTY0XzEuYmFzZTY0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlIH0pLCA0NCwgNDQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzdW0uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hlY2tzdW1TdHJ1Y3QiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImJhc2U2NF8xIiwic2l6ZSIsImJhc2U2NCIsInN0cmluZyIsInBhZGRpbmdSZXF1aXJlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/coercers.js":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/coercers.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@metamask/utils/dist/bytes.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.js\");\nconst NumberLikeStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.bigint)(),\n    (0, superstruct_1.string)(),\n    hex_1.StrictHexStruct\n]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([\n    hex_1.StrictHexStruct,\n    (0, superstruct_1.instance)(Uint8Array)\n]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([\n    hex_1.StrictHexStruct\n]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */ function createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */ function createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */ function createBytes(value) {\n    if (typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */ function createHex(value) {\n    if (value instanceof Uint8Array && value.length === 0 || typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return \"0x\";\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createHex = createHex; //# sourceMappingURL=coercers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29lcmNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDN0YsTUFBTU0sZ0JBQWdCQyxtQkFBT0EsQ0FBQyxpR0FBYTtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxxRUFBVTtBQUNuQyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNRyxRQUFRSCxtQkFBT0EsQ0FBQywrREFBTztBQUM3QixNQUFNSSxtQkFBbUIsQ0FBQyxHQUFHTCxjQUFjTSxLQUFLLEVBQUU7SUFBRSxJQUFHTixjQUFjTyxNQUFNO0lBQU0sSUFBR1AsY0FBY1EsTUFBTTtJQUFNLElBQUdSLGNBQWNTLE1BQU07SUFBS0wsTUFBTU0sZUFBZTtDQUFDO0FBQ2hLLE1BQU1DLGdCQUFnQixDQUFDLEdBQUdYLGNBQWNZLE1BQU0sRUFBRSxDQUFDLEdBQUdaLGNBQWNPLE1BQU0sS0FBS0Ysa0JBQWtCUTtBQUMvRixNQUFNQyxnQkFBZ0IsQ0FBQyxHQUFHZCxjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjUSxNQUFNLEtBQUtILGtCQUFrQlU7QUFDL0YsTUFBTUMsa0JBQWtCLENBQUMsR0FBR2hCLGNBQWNNLEtBQUssRUFBRTtJQUFDRixNQUFNTSxlQUFlO0lBQUcsSUFBR1YsY0FBY2lCLFFBQVEsRUFBRUM7Q0FBWTtBQUNqSCxNQUFNQyxlQUFlLENBQUMsR0FBR25CLGNBQWNZLE1BQU0sRUFBRSxDQUFDLEdBQUdaLGNBQWNpQixRQUFRLEVBQUVDLGFBQWEsQ0FBQyxHQUFHbEIsY0FBY00sS0FBSyxFQUFFO0lBQUNGLE1BQU1NLGVBQWU7Q0FBQyxHQUFHUCxRQUFRaUIsVUFBVTtBQUM3SixNQUFNQyxhQUFhLENBQUMsR0FBR3JCLGNBQWNZLE1BQU0sRUFBRVIsTUFBTU0sZUFBZSxFQUFFLENBQUMsR0FBR1YsY0FBY2lCLFFBQVEsRUFBRUMsYUFBYWYsUUFBUW1CLFVBQVU7QUFDL0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNELFNBQVN2QixhQUFhSixLQUFLO0lBQ3ZCLElBQUk7UUFDQSxNQUFNNEIsU0FBUyxDQUFDLEdBQUd2QixjQUFjd0IsTUFBTSxFQUFFN0IsT0FBT2dCO1FBQy9DLElBQUdULFNBQVN1QixNQUFNLEVBQUVaLE9BQU9hLFFBQVEsQ0FBQ0gsU0FBUyxDQUFDLG1DQUFtQyxFQUFFNUIsTUFBTSxFQUFFLENBQUM7UUFDN0YsT0FBTzRCO0lBQ1gsRUFDQSxPQUFPSSxPQUFPO1FBQ1YsSUFBSUEsaUJBQWlCM0IsY0FBYzRCLFdBQVcsRUFBRTtZQUM1QyxNQUFNLElBQUlDLE1BQU0sQ0FBQyxtQ0FBbUMsRUFBRWxDLE1BQU0sRUFBRSxDQUFDO1FBQ25FO1FBQ0Esd0JBQXdCLEdBQ3hCLE1BQU1nQztJQUNWO0FBQ0o7QUFDQWpDLG9CQUFvQixHQUFHSztBQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0QsU0FBU0QsYUFBYUgsS0FBSztJQUN2QixJQUFJO1FBQ0EsMkVBQTJFO1FBQzNFLG1EQUFtRDtRQUNuRCxPQUFPLENBQUMsR0FBR0ssY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU9tQjtJQUM1QyxFQUNBLE9BQU9hLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLG1DQUFtQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNqRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxvQkFBb0IsR0FBR0k7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNELFlBQVlGLEtBQUs7SUFDdEIsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLE1BQU1vQyxXQUFXLE9BQU8sTUFBTTtRQUMzRCxPQUFPLElBQUliO0lBQ2Y7SUFDQSxJQUFJO1FBQ0EsT0FBTyxDQUFDLEdBQUdsQixjQUFjd0IsTUFBTSxFQUFFN0IsT0FBT3dCO0lBQzVDLEVBQ0EsT0FBT1EsT0FBTztRQUNWLElBQUlBLGlCQUFpQjNCLGNBQWM0QixXQUFXLEVBQUU7WUFDNUMsTUFBTSxJQUFJQyxNQUFNLENBQUMsa0NBQWtDLEVBQUVDLE9BQU9ILE1BQU1oQyxLQUFLLEVBQUUsRUFBRSxDQUFDO1FBQ2hGO1FBQ0Esd0JBQXdCLEdBQ3hCLE1BQU1nQztJQUNWO0FBQ0o7QUFDQWpDLG1CQUFtQixHQUFHRztBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0QsU0FBU0QsVUFBVUQsS0FBSztJQUNwQixJQUFJLGlCQUFrQnVCLGNBQWN2QixNQUFNcUMsTUFBTSxLQUFLLEtBQ2hELE9BQU9yQyxVQUFVLFlBQVlBLE1BQU1vQyxXQUFXLE9BQU8sTUFBTztRQUM3RCxPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsT0FBTyxDQUFDLEdBQUcvQixjQUFjd0IsTUFBTSxFQUFFN0IsT0FBTzBCO0lBQzVDLEVBQ0EsT0FBT00sT0FBTztRQUNWLElBQUlBLGlCQUFpQjNCLGNBQWM0QixXQUFXLEVBQUU7WUFDNUMsTUFBTSxJQUFJQyxNQUFNLENBQUMsa0NBQWtDLEVBQUVDLE9BQU9ILE1BQU1oQyxLQUFLLEVBQUUsRUFBRSxDQUFDO1FBQ2hGO1FBQ0Esd0JBQXdCLEdBQ3hCLE1BQU1nQztJQUNWO0FBQ0o7QUFDQWpDLGlCQUFpQixHQUFHRSxXQUNwQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29lcmNlcnMuanM/NDJiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbmNvbnN0IE51bWJlckxpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGhleF8xLlN0cmljdEhleFN0cnVjdF0pO1xuY29uc3QgTnVtYmVyQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCBOdW1iZXJMaWtlU3RydWN0LCBOdW1iZXIpO1xuY29uc3QgQmlnSW50Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCBOdW1iZXJMaWtlU3RydWN0LCBCaWdJbnQpO1xuY29uc3QgQnl0ZXNMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KV0pO1xuY29uc3QgQnl0ZXNDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0XSksIGJ5dGVzXzEuaGV4VG9CeXRlcyk7XG5jb25zdCBIZXhDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKShoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgYnl0ZXNfMS5ieXRlc1RvSGV4KTtcbi8qKlxuICogQ3JlYXRlIGEgbnVtYmVyIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIFRoaXMgdmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVOdW1iZXIoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDY2MDUxXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZU51bWJlcigxMjNuKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgbnVtYmVyIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZSwgb3IgaWYgdGhlIHJlc3VsdGluZyBudW1iZXJcbiAqIGlzIGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlcih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIE51bWJlckNvZXJjZXIpO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNGaW5pdGUocmVzdWx0KSwgYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSBjcmVhdGVOdW1iZXI7XG4vKipcbiAqIENyZWF0ZSBhIGBiaWdpbnRgIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyIGFuZFxuICogY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQmlnSW50KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAxNjkwOTA2MG5cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQmlnSW50KDEyMyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzblxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBiaWdpbnQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJpZ2ludC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCaWdJbnQodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB2YWxpZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkuXG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCaWdJbnRDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQmlnSW50ID0gY3JlYXRlQmlnSW50O1xuLyoqXG4gKiBDcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYnl0ZSBhcnJheSwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIGludGVycHJldGVkXG4gKiBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJ5dGUgYXJyYXkgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJ5dGUgYXJyYXkuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCeXRlc0NvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJ5dGVzID0gY3JlYXRlQnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIGhleGFkZWNpbWFsIHN0cmluZyBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIHJldHVybmVkXG4gKiBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUhleChuZXcgVWludDhBcnJheShbMSwgMiwgM10pKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVIZXgoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBoZXggc3RyaW5nIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBoZXggc3RyaW5nLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGV4KHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEhleENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUhleCA9IGNyZWF0ZUhleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUhleCIsImNyZWF0ZUJ5dGVzIiwiY3JlYXRlQmlnSW50IiwiY3JlYXRlTnVtYmVyIiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJhc3NlcnRfMSIsImJ5dGVzXzEiLCJoZXhfMSIsIk51bWJlckxpa2VTdHJ1Y3QiLCJ1bmlvbiIsIm51bWJlciIsImJpZ2ludCIsInN0cmluZyIsIlN0cmljdEhleFN0cnVjdCIsIk51bWJlckNvZXJjZXIiLCJjb2VyY2UiLCJOdW1iZXIiLCJCaWdJbnRDb2VyY2VyIiwiQmlnSW50IiwiQnl0ZXNMaWtlU3RydWN0IiwiaW5zdGFuY2UiLCJVaW50OEFycmF5IiwiQnl0ZXNDb2VyY2VyIiwiaGV4VG9CeXRlcyIsIkhleENvZXJjZXIiLCJieXRlc1RvSGV4IiwicmVzdWx0IiwiY3JlYXRlIiwiYXNzZXJ0IiwiaXNGaW5pdGUiLCJlcnJvciIsIlN0cnVjdEVycm9yIiwiRXJyb3IiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/coercers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/collections.js":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/collections.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */ class FrozenMap {\n    constructor(entries){\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map)=>callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.entries()\n        ].map(([key, value])=>`${String(key)} => ${String(value)}`).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */ class FrozenSet {\n    constructor(values){\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set)=>callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.values()\n        ].map((member)=>String(member)).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype); //# sourceMappingURL=collections.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSx5QkFBeUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxzQkFBc0IsSUFBSyxTQUFVQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLENBQUM7SUFDM0csSUFBSUQsU0FBUyxLQUFLLE1BQU0sSUFBSUUsVUFBVTtJQUN0QyxJQUFJRixTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSixVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0csSUFBSSxDQUFDSCxNQUFNSyxHQUFHLENBQUNOLFdBQVcsTUFBTSxJQUFJSyxVQUFVO0lBQ3ZHLE9BQU8sU0FBVSxNQUFNRCxFQUFFRyxJQUFJLENBQUNQLFVBQVVFLFNBQVNFLElBQUlBLEVBQUVGLEtBQUssR0FBR0EsUUFBUUQsTUFBTU8sR0FBRyxDQUFDUixVQUFVRSxRQUFTQTtBQUN4RztBQUNBLElBQUlPLHlCQUF5QixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxnQkFBZ0JDO0FBQ3BCQyw4Q0FBNkM7SUFBRVgsT0FBTztB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QUksRUFBRUcsZ0JBQWdCLEtBQUtjLE9BQU8sQ0FBQyxDQUFDeEIsT0FBT29DLFFBQVFDLE9BQVNaLFdBQVdwQixJQUFJLENBQUNxQixTQUFTMUIsT0FBT29DLFFBQVEsSUFBSTtJQUMxSTtJQUNBaEMsSUFBSUosS0FBSyxFQUFFO1FBQ1AsT0FBT08sdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtOLEdBQUcsQ0FBQ0o7SUFDakU7SUFDQTZCLE9BQU87UUFDSCxPQUFPdEIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUttQixJQUFJO0lBQ2pFO0lBQ0FDLFNBQVM7UUFDTCxPQUFPdkIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtvQixNQUFNO0lBQ25FO0lBQ0FDLFdBQVc7UUFDUCxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQ1gsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUNBLElBQUksR0FBRyxJQUN6QyxDQUFDLENBQUMsRUFBRTtlQUFJLElBQUksQ0FBQ1UsTUFBTTtTQUFHLENBQUNFLEdBQUcsQ0FBQyxDQUFDTSxTQUFXTCxPQUFPSyxTQUFTSixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FDcEUsR0FBRyxDQUFDLENBQUM7SUFDZjtBQUNKO0FBQ0FyQixpQkFBaUIsR0FBR0M7QUFDcEJILE9BQU9RLE1BQU0sQ0FBQ0o7QUFDZEosT0FBT1EsTUFBTSxDQUFDSixVQUFVd0IsU0FBUztBQUNqQzVCLE9BQU9RLE1BQU0sQ0FBQ0w7QUFDZEgsT0FBT1EsTUFBTSxDQUFDTCxVQUFVeUIsU0FBUyxHQUNqQyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanM/ZWE1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRnJvemVuTWFwX21hcCwgX0Zyb3plblNldF9zZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyb3plblNldCA9IGV4cG9ydHMuRnJvemVuTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seU1hcH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIG1hcCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgbWFwLlxuICovXG5jbGFzcyBGcm96ZW5NYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgX0Zyb3plbk1hcF9tYXAuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIG5ldyBNYXAoZW50cmllcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBtYXAuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZm9yRWFjaCgodmFsdWUsIGtleSwgX21hcCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plbk1hcCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke1N0cmluZyhrZXkpfSA9PiAke1N0cmluZyh2YWx1ZSl9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlTZXR9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBzZXQgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIHNldC5cbiAqL1xuY2xhc3MgRnJvemVuU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgX0Zyb3plblNldF9zZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plblNldF9zZXQsIG5ldyBTZXQodmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5TZXRfc2V0ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHNldC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwgdmFsdWUyLCBfc2V0KSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlMiwgdGhpcykpO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy52YWx1ZXMoKV0ubWFwKChtZW1iZXIpID0+IFN0cmluZyhtZW1iZXIpKS5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuU2V0ID0gRnJvemVuU2V0O1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXApO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXAucHJvdG90eXBlKTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0KTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0LnByb3RvdHlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfRnJvemVuTWFwX21hcCIsIl9Gcm96ZW5TZXRfc2V0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiRnJvemVuU2V0IiwiRnJvemVuTWFwIiwiY29uc3RydWN0b3IiLCJlbnRyaWVzIiwiTWFwIiwiZnJlZXplIiwic2l6ZSIsIldlYWtNYXAiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZvckVhY2giLCJjYWxsYmFja2ZuIiwidGhpc0FyZyIsImtleSIsIl9tYXAiLCJrZXlzIiwidmFsdWVzIiwidG9TdHJpbmciLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiU2V0IiwidmFsdWUyIiwiX3NldCIsIm1lbWJlciIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/collections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/hex.js":
/*!**************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/hex.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isHexString(value) {\n    return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isStrictHexString(value) {\n    return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), \"Value must be a hexadecimal string.\");\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */ function add0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\")) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith(\"0X\")) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */ function remove0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\") || hexadecimal.startsWith(\"0X\")) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x; //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsYUFBYSxHQUFHQSwrQkFBK0IsR0FBR0EseUJBQXlCLEdBQUdBLHlCQUF5QixHQUFHQSxtQkFBbUIsR0FBR0EsdUJBQXVCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDdE0sTUFBTVUsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxpR0FBYTtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxxRUFBVTtBQUNuQ1gsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHVSxjQUFjRyxPQUFPLEVBQUUsQ0FBQyxHQUFHSCxjQUFjSSxNQUFNLEtBQUs7QUFDNUVkLHVCQUF1QixHQUFHLENBQUMsR0FBR1UsY0FBY0csT0FBTyxFQUFFLENBQUMsR0FBR0gsY0FBY0ksTUFBTSxLQUFLO0FBQ2xGOzs7OztDQUtDLEdBQ0QsU0FBU1AsWUFBWU4sS0FBSztJQUN0QixPQUFPLENBQUMsR0FBR1MsY0FBY0ssRUFBRSxFQUFFZCxPQUFPRCxRQUFRUyxTQUFTO0FBQ3pEO0FBQ0FULG1CQUFtQixHQUFHTztBQUN0Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxrQkFBa0JMLEtBQUs7SUFDNUIsT0FBTyxDQUFDLEdBQUdTLGNBQWNLLEVBQUUsRUFBRWQsT0FBT0QsUUFBUVEsZUFBZTtBQUMvRDtBQUNBUix5QkFBeUIsR0FBR007QUFDNUI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxrQkFBa0JKLEtBQUs7SUFDM0IsSUFBR1csU0FBU0ksTUFBTSxFQUFFVCxZQUFZTixRQUFRO0FBQzdDO0FBQ0FELHlCQUF5QixHQUFHSztBQUM1Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCx3QkFBd0JILEtBQUs7SUFDakMsSUFBR1csU0FBU0ksTUFBTSxFQUFFVixrQkFBa0JMLFFBQVE7QUFDbkQ7QUFDQUQsK0JBQStCLEdBQUdJO0FBQ2xDOzs7Ozs7Q0FNQyxHQUNELFNBQVNELE1BQU1jLFdBQVc7SUFDdEIsSUFBSUEsWUFBWUMsVUFBVSxDQUFDLE9BQU87UUFDOUIsT0FBT0Q7SUFDWDtJQUNBLElBQUlBLFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlCLE9BQU8sQ0FBQyxFQUFFLEVBQUVELFlBQVlFLFNBQVMsQ0FBQyxHQUFHLENBQUM7SUFDMUM7SUFDQSxPQUFPLENBQUMsRUFBRSxFQUFFRixZQUFZLENBQUM7QUFDN0I7QUFDQWpCLGFBQWEsR0FBR0c7QUFDaEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsU0FBU2UsV0FBVztJQUN6QixJQUFJQSxZQUFZQyxVQUFVLENBQUMsU0FBU0QsWUFBWUMsVUFBVSxDQUFDLE9BQU87UUFDOUQsT0FBT0QsWUFBWUUsU0FBUyxDQUFDO0lBQ2pDO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBakIsZ0JBQWdCLEdBQUdFLFVBQ25CLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXguanM/ZTExYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8qKlxuICogU3RyaWN0bHkgY2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdFxuICogc3RhcnQgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGlzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlbW92ZTB4IiwiYWRkMHgiLCJhc3NlcnRJc1N0cmljdEhleFN0cmluZyIsImFzc2VydElzSGV4U3RyaW5nIiwiaXNTdHJpY3RIZXhTdHJpbmciLCJpc0hleFN0cmluZyIsIlN0cmljdEhleFN0cnVjdCIsIkhleFN0cnVjdCIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJwYXR0ZXJuIiwic3RyaW5nIiwiaXMiLCJhc3NlcnQiLCJoZXhhZGVjaW1hbCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\"), exports);\n__exportStar(__webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/@metamask/utils/dist/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@metamask/utils/dist/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/@metamask/utils/dist/checksum.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers */ \"(ssr)/./node_modules/@metamask/utils/dist/coercers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./collections */ \"(ssr)/./node_modules/@metamask/utils/dist/collections.js\"), exports);\n__exportStar(__webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.js\"), exports);\n__exportStar(__webpack_require__(/*! ./json */ \"(ssr)/./node_modules/@metamask/utils/dist/json.js\"), exports);\n__exportStar(__webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@metamask/utils/dist/logging.js\"), exports);\n__exportStar(__webpack_require__(/*! ./misc */ \"(ssr)/./node_modules/@metamask/utils/dist/misc.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(ssr)/./node_modules/@metamask/utils/dist/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque */ \"(ssr)/./node_modules/@metamask/utils/dist/opaque.js\"), exports);\n__exportStar(__webpack_require__(/*! ./time */ \"(ssr)/./node_modules/@metamask/utils/dist/time.js\"), exports);\n__exportStar(__webpack_require__(/*! ./versions */ \"(ssr)/./node_modules/@metamask/utils/dist/versions.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLHFFQUFVLEdBQUdOO0FBQ2xDRCxhQUFhTyxtQkFBT0EsQ0FBQyxxRUFBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsbUVBQVMsR0FBR047QUFDakNELGFBQWFPLG1CQUFPQSxDQUFDLHlFQUFZLEdBQUdOO0FBQ3BDRCxhQUFhTyxtQkFBT0EsQ0FBQyx5RUFBWSxHQUFHTjtBQUNwQ0QsYUFBYU8sbUJBQU9BLENBQUMsK0VBQWUsR0FBR047QUFDdkNELGFBQWFPLG1CQUFPQSxDQUFDLCtEQUFPLEdBQUdOO0FBQy9CRCxhQUFhTyxtQkFBT0EsQ0FBQyxpRUFBUSxHQUFHTjtBQUNoQ0QsYUFBYU8sbUJBQU9BLENBQUMsdUVBQVcsR0FBR047QUFDbkNELGFBQWFPLG1CQUFPQSxDQUFDLGlFQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQyxxRUFBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMscUVBQVUsR0FBR047QUFDbENELGFBQWFPLG1CQUFPQSxDQUFDLGlFQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQyx5RUFBWSxHQUFHTixVQUNwQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaW5kZXguanM/MmRmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTY0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hlY2tzdW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvZXJjZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGV4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9taXNjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9udW1iZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wYXF1ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/json.js":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/json.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\nconst misc_1 = __webpack_require__(/*! ./misc */ \"(ssr)/./node_modules/@metamask/utils/dist/misc.js\");\nexports.JsonStruct = (0, superstruct_1.define)(\"Json\", (value)=>{\n    const [isValid] = validateJsonAndGetSize(value, true);\n    if (!isValid) {\n        return \"Expected a valid JSON-serializable value\";\n    }\n    return true;\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */ function isValidJson(value) {\n    return (0, superstruct_1.is)(value, exports.JsonStruct);\n}\nexports.isValidJson = isValidJson;\n/**\n * The string '2.0'.\n */ exports.jsonrpc2 = \"2.0\";\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.string)()\n]));\nexports.JsonRpcErrorStruct = (0, superstruct_1.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: (0, superstruct_1.optional)(exports.JsonStruct),\n    stack: (0, superstruct_1.optional)((0, superstruct_1.string)())\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([\n    (0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct),\n    (0, superstruct_1.array)(exports.JsonStruct)\n]));\nexports.JsonRpcRequestStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exports.JsonRpcParamsStruct\n});\nexports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, [\n    \"id\"\n]);\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */ function isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */ function assertIsJsonRpcNotification(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, \"Invalid JSON-RPC notification\", ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */ function isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */ function assertIsJsonRpcRequest(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, \"Invalid JSON-RPC request\", ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)\n});\nexports.JsonRpcSuccessStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct\n});\nexports.JsonRpcFailureStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */ function isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */ function assertIsPendingJsonRpcResponse(response, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, \"Invalid pending JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */ function isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */ function assertIsJsonRpcResponse(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, \"Invalid JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */ function isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */ function assertIsJsonRpcSuccess(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, \"Invalid JSON-RPC success response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */ function isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */ function assertIsJsonRpcFailure(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, \"Invalid JSON-RPC failure response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */ function isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */ function assertIsJsonRpcError(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, \"Invalid JSON-RPC error\", ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */ function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = Object.assign({\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true\n    }, options);\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */ const isValidJsonRpcId = (id)=>{\n        return Boolean(typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null);\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator;\n/**\n * Checks whether a value is JSON serializable and counts the total number\n * of bytes needed to store the serialized version of the value.\n *\n * @param jsObject - Potential JSON serializable object.\n * @param skipSizingProcess - Skip JSON size calculation (default: false).\n * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether\n * the value was serializable and a number of bytes that it will use when serialized to JSON.\n */ function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {\n    const seenObjects = new Set();\n    /**\n     * Checks whether a value is JSON serializable and counts the total number\n     * of bytes needed to store the serialized version of the value.\n     *\n     * This function assumes the encoding of the JSON is done in UTF-8.\n     *\n     * @param value - Potential JSON serializable value.\n     * @param skipSizing - Skip JSON size calculation (default: false).\n     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether\n     * the value was serializable and a number of bytes that it will use when serialized to JSON.\n     */ function getJsonSerializableInfo(value, skipSizing) {\n        if (value === undefined) {\n            return [\n                false,\n                0\n            ];\n        } else if (value === null) {\n            // Return already specified constant size for null (special object)\n            return [\n                true,\n                skipSizing ? 0 : misc_1.JsonSize.Null\n            ];\n        }\n        // Check and calculate sizes for basic (and some special) types\n        const typeOfValue = typeof value;\n        try {\n            if (typeOfValue === \"function\") {\n                return [\n                    false,\n                    0\n                ];\n            } else if (typeOfValue === \"string\" || value instanceof String) {\n                return [\n                    true,\n                    skipSizing ? 0 : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2\n                ];\n            } else if (typeOfValue === \"boolean\" || value instanceof Boolean) {\n                if (skipSizing) {\n                    return [\n                        true,\n                        0\n                    ];\n                }\n                // eslint-disable-next-line eqeqeq\n                return [\n                    true,\n                    value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False\n                ];\n            } else if (typeOfValue === \"number\" || value instanceof Number) {\n                if (skipSizing) {\n                    return [\n                        true,\n                        0\n                    ];\n                }\n                return [\n                    true,\n                    (0, misc_1.calculateNumberSize)(value)\n                ];\n            } else if (value instanceof Date) {\n                if (skipSizing) {\n                    return [\n                        true,\n                        0\n                    ];\n                }\n                return [\n                    true,\n                    // Note: Invalid dates will serialize to null\n                    isNaN(value.getDate()) ? misc_1.JsonSize.Null : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2\n                ];\n            }\n        } catch (_) {\n            return [\n                false,\n                0\n            ];\n        }\n        // If object is not plain and cannot be serialized properly,\n        // stop here and return false for serialization\n        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {\n            return [\n                false,\n                0\n            ];\n        }\n        // Circular object detection (handling)\n        // Check if the same object already exists\n        if (seenObjects.has(value)) {\n            return [\n                false,\n                0\n            ];\n        }\n        // Add new object to the seen objects set\n        // Only the plain objects should be added (Primitive types are skipped)\n        seenObjects.add(value);\n        // Continue object decomposition\n        try {\n            return [\n                true,\n                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr)=>{\n                    // Recursively process next nested object or primitive type\n                    // eslint-disable-next-line prefer-const\n                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);\n                    if (!valid) {\n                        throw new Error(\"JSON validation did not pass. Validation process stopped.\");\n                    }\n                    // Circular object detection\n                    // Once a child node is visited and processed remove it from the set.\n                    // This will prevent false positives with the same adjacent objects.\n                    seenObjects.delete(value);\n                    if (skipSizing) {\n                        return 0;\n                    }\n                    // Objects will have be serialized with \"key\": value,\n                    // therefore we include the key in the calculation here\n                    const keySize = Array.isArray(value) ? 0 : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;\n                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;\n                    return sum + keySize + size + separator;\n                }, // Starts at 2 because the serialized JSON string data (plain text)\n                // will minimally contain {}/[]\n                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2)\n            ];\n        } catch (_) {\n            return [\n                false,\n                0\n            ];\n        }\n    }\n    return getJsonSerializableInfo(jsObject, skipSizingProcess);\n}\nexports.validateJsonAndGetSize = validateJsonAndGetSize; //# sourceMappingURL=json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLDZCQUE2QixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsOEJBQThCLEdBQUdBLHdCQUF3QixHQUFHQSwrQkFBK0IsR0FBR0EseUJBQXlCLEdBQUdBLHNDQUFzQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsNkJBQTZCLEdBQUdBLDRCQUE0QixHQUFHQSw0QkFBNEIsR0FBR0Esb0NBQW9DLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsbUNBQW1DLEdBQUdBLDZCQUE2QixHQUFHQSxpQ0FBaUMsR0FBR0EsNEJBQTRCLEdBQUdBLDJCQUEyQixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUdBLDRCQUE0QixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDNTNCLE1BQU0rQixnQkFBZ0JDLG1CQUFPQSxDQUFDLGlHQUFhO0FBQzNDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLHFFQUFVO0FBQ25DLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLGlFQUFRO0FBQy9CaEMsa0JBQWtCLEdBQUcsQ0FBQyxHQUFHK0IsY0FBY0ksTUFBTSxFQUFFLFFBQVEsQ0FBQ2xDO0lBQ3BELE1BQU0sQ0FBQ21DLFFBQVEsR0FBR2xDLHVCQUF1QkQsT0FBTztJQUNoRCxJQUFJLENBQUNtQyxTQUFTO1FBQ1YsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU1AsWUFBWTVCLEtBQUs7SUFDdEIsT0FBTyxDQUFDLEdBQUc4QixjQUFjTSxFQUFFLEVBQUVwQyxPQUFPRCxRQUFROEIsVUFBVTtBQUMxRDtBQUNBOUIsbUJBQW1CLEdBQUc2QjtBQUN0Qjs7Q0FFQyxHQUNEN0IsZ0JBQWdCLEdBQUc7QUFDbkJBLDRCQUE0QixHQUFHLENBQUMsR0FBRytCLGNBQWNPLE9BQU8sRUFBRXRDLFFBQVE0QixRQUFRO0FBQzFFNUIsdUJBQXVCLEdBQUcsQ0FBQyxHQUFHK0IsY0FBY1EsUUFBUSxFQUFFLENBQUMsR0FBR1IsY0FBY1MsS0FBSyxFQUFFO0lBQUUsSUFBR1QsY0FBY1UsTUFBTTtJQUFNLElBQUdWLGNBQWNXLE1BQU07Q0FBSTtBQUN6STFDLDBCQUEwQixHQUFHLENBQUMsR0FBRytCLGNBQWNZLE1BQU0sRUFBRTtJQUNuREMsTUFBTSxDQUFDLEdBQUdiLGNBQWNjLE9BQU87SUFDL0JDLFNBQVMsQ0FBQyxHQUFHZixjQUFjVyxNQUFNO0lBQ2pDSyxNQUFNLENBQUMsR0FBR2hCLGNBQWNpQixRQUFRLEVBQUVoRCxRQUFROEIsVUFBVTtJQUNwRG1CLE9BQU8sQ0FBQyxHQUFHbEIsY0FBY2lCLFFBQVEsRUFBRSxDQUFDLEdBQUdqQixjQUFjVyxNQUFNO0FBQy9EO0FBQ0ExQywyQkFBMkIsR0FBRyxDQUFDLEdBQUcrQixjQUFjaUIsUUFBUSxFQUFFLENBQUMsR0FBR2pCLGNBQWNTLEtBQUssRUFBRTtJQUFFLElBQUdULGNBQWNtQixNQUFNLEVBQUUsQ0FBQyxHQUFHbkIsY0FBY1csTUFBTSxLQUFLMUMsUUFBUThCLFVBQVU7SUFBSSxJQUFHQyxjQUFjb0IsS0FBSyxFQUFFbkQsUUFBUThCLFVBQVU7Q0FBRTtBQUM3TTlCLDRCQUE0QixHQUFHLENBQUMsR0FBRytCLGNBQWNZLE1BQU0sRUFBRTtJQUNyRFMsSUFBSXBELFFBQVEwQixlQUFlO0lBQzNCMkIsU0FBU3JELFFBQVEyQixvQkFBb0I7SUFDckMyQixRQUFRLENBQUMsR0FBR3ZCLGNBQWNXLE1BQU07SUFDaENhLFFBQVF2RCxRQUFRd0IsbUJBQW1CO0FBQ3ZDO0FBQ0F4QixpQ0FBaUMsR0FBRyxDQUFDLEdBQUcrQixjQUFjeUIsSUFBSSxFQUFFeEQsUUFBUXVCLG9CQUFvQixFQUFFO0lBQUM7Q0FBSztBQUNoRzs7Ozs7O0NBTUMsR0FDRCxTQUFTRixzQkFBc0JwQixLQUFLO0lBQ2hDLE9BQU8sQ0FBQyxHQUFHOEIsY0FBY00sRUFBRSxFQUFFcEMsT0FBT0QsUUFBUXNCLHlCQUF5QjtBQUN6RTtBQUNBdEIsNkJBQTZCLEdBQUdxQjtBQUNoQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0QsNEJBQTRCbkIsS0FBSyxFQUMxQyxnRUFBZ0U7QUFDaEV3RCxZQUFZO0lBQ1AsSUFBR3hCLFNBQVN5QixZQUFZLEVBQUV6RCxPQUFPRCxRQUFRc0IseUJBQXlCLEVBQUUsaUNBQWlDbUM7QUFDMUc7QUFDQXpELG1DQUFtQyxHQUFHb0I7QUFDdEM7Ozs7O0NBS0MsR0FDRCxTQUFTRCxpQkFBaUJsQixLQUFLO0lBQzNCLE9BQU8sQ0FBQyxHQUFHOEIsY0FBY00sRUFBRSxFQUFFcEMsT0FBT0QsUUFBUXVCLG9CQUFvQjtBQUNwRTtBQUNBdkIsd0JBQXdCLEdBQUdtQjtBQUMzQjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0QsdUJBQXVCakIsS0FBSyxFQUNyQyxnRUFBZ0U7QUFDaEV3RCxZQUFZO0lBQ1AsSUFBR3hCLFNBQVN5QixZQUFZLEVBQUV6RCxPQUFPRCxRQUFRdUIsb0JBQW9CLEVBQUUsNEJBQTRCa0M7QUFDaEc7QUFDQXpELDhCQUE4QixHQUFHa0I7QUFDakNsQixvQ0FBb0MsR0FBRyxDQUFDLEdBQUcrQixjQUFjWSxNQUFNLEVBQUU7SUFDN0RTLElBQUlwRCxRQUFRMEIsZUFBZTtJQUMzQjJCLFNBQVNyRCxRQUFRMkIsb0JBQW9CO0lBQ3JDZ0MsUUFBUSxDQUFDLEdBQUc1QixjQUFjaUIsUUFBUSxFQUFFLENBQUMsR0FBR2pCLGNBQWM2QixPQUFPO0lBQzdEQyxPQUFPLENBQUMsR0FBRzlCLGNBQWNpQixRQUFRLEVBQUVoRCxRQUFReUIsa0JBQWtCO0FBQ2pFO0FBQ0F6Qiw0QkFBNEIsR0FBRyxDQUFDLEdBQUcrQixjQUFjWSxNQUFNLEVBQUU7SUFDckRTLElBQUlwRCxRQUFRMEIsZUFBZTtJQUMzQjJCLFNBQVNyRCxRQUFRMkIsb0JBQW9CO0lBQ3JDZ0MsUUFBUTNELFFBQVE4QixVQUFVO0FBQzlCO0FBQ0E5Qiw0QkFBNEIsR0FBRyxDQUFDLEdBQUcrQixjQUFjWSxNQUFNLEVBQUU7SUFDckRTLElBQUlwRCxRQUFRMEIsZUFBZTtJQUMzQjJCLFNBQVNyRCxRQUFRMkIsb0JBQW9CO0lBQ3JDa0MsT0FBTzdELFFBQVF5QixrQkFBa0I7QUFDckM7QUFDQXpCLDZCQUE2QixHQUFHLENBQUMsR0FBRytCLGNBQWNTLEtBQUssRUFBRTtJQUNyRHhDLFFBQVFnQixvQkFBb0I7SUFDNUJoQixRQUFRZSxvQkFBb0I7Q0FDL0I7QUFDRDs7Ozs7O0NBTUMsR0FDRCxTQUFTRix5QkFBeUJpRCxRQUFRO0lBQ3RDLE9BQU8sQ0FBQyxHQUFHL0IsY0FBY00sRUFBRSxFQUFFeUIsVUFBVTlELFFBQVFpQiw0QkFBNEI7QUFDL0U7QUFDQWpCLGdDQUFnQyxHQUFHYTtBQUNuQzs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNELCtCQUErQmtELFFBQVEsRUFDaEQsZ0VBQWdFO0FBQ2hFTCxZQUFZO0lBQ1AsSUFBR3hCLFNBQVN5QixZQUFZLEVBQUVJLFVBQVU5RCxRQUFRaUIsNEJBQTRCLEVBQUUscUNBQXFDd0M7QUFDcEg7QUFDQXpELHNDQUFzQyxHQUFHWTtBQUN6Qzs7Ozs7Q0FLQyxHQUNELFNBQVNELGtCQUFrQm1ELFFBQVE7SUFDL0IsT0FBTyxDQUFDLEdBQUcvQixjQUFjTSxFQUFFLEVBQUV5QixVQUFVOUQsUUFBUWMscUJBQXFCO0FBQ3hFO0FBQ0FkLHlCQUF5QixHQUFHVztBQUM1Qjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0Qsd0JBQXdCVCxLQUFLLEVBQ3RDLGdFQUFnRTtBQUNoRXdELFlBQVk7SUFDUCxJQUFHeEIsU0FBU3lCLFlBQVksRUFBRXpELE9BQU9ELFFBQVFjLHFCQUFxQixFQUFFLDZCQUE2QjJDO0FBQ2xHO0FBQ0F6RCwrQkFBK0IsR0FBR1U7QUFDbEM7Ozs7O0NBS0MsR0FDRCxTQUFTRCxpQkFBaUJSLEtBQUs7SUFDM0IsT0FBTyxDQUFDLEdBQUc4QixjQUFjTSxFQUFFLEVBQUVwQyxPQUFPRCxRQUFRZ0Isb0JBQW9CO0FBQ3BFO0FBQ0FoQix3QkFBd0IsR0FBR1M7QUFDM0I7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHVCQUF1QlAsS0FBSyxFQUNyQyxnRUFBZ0U7QUFDaEV3RCxZQUFZO0lBQ1AsSUFBR3hCLFNBQVN5QixZQUFZLEVBQUV6RCxPQUFPRCxRQUFRZ0Isb0JBQW9CLEVBQUUscUNBQXFDeUM7QUFDekc7QUFDQXpELDhCQUE4QixHQUFHUTtBQUNqQzs7Ozs7Q0FLQyxHQUNELFNBQVNELGlCQUFpQk4sS0FBSztJQUMzQixPQUFPLENBQUMsR0FBRzhCLGNBQWNNLEVBQUUsRUFBRXBDLE9BQU9ELFFBQVFlLG9CQUFvQjtBQUNwRTtBQUNBZix3QkFBd0IsR0FBR087QUFDM0I7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHVCQUF1QkwsS0FBSyxFQUNyQyxnRUFBZ0U7QUFDaEV3RCxZQUFZO0lBQ1AsSUFBR3hCLFNBQVN5QixZQUFZLEVBQUV6RCxPQUFPRCxRQUFRZSxvQkFBb0IsRUFBRSxxQ0FBcUMwQztBQUN6RztBQUNBekQsOEJBQThCLEdBQUdNO0FBQ2pDOzs7OztDQUtDLEdBQ0QsU0FBU0QsZUFBZUosS0FBSztJQUN6QixPQUFPLENBQUMsR0FBRzhCLGNBQWNNLEVBQUUsRUFBRXBDLE9BQU9ELFFBQVF5QixrQkFBa0I7QUFDbEU7QUFDQXpCLHNCQUFzQixHQUFHSztBQUN6Qjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0QscUJBQXFCSCxLQUFLLEVBQ25DLGdFQUFnRTtBQUNoRXdELFlBQVk7SUFDUCxJQUFHeEIsU0FBU3lCLFlBQVksRUFBRXpELE9BQU9ELFFBQVF5QixrQkFBa0IsRUFBRSwwQkFBMEJnQztBQUM1RjtBQUNBekQsNEJBQTRCLEdBQUdJO0FBQy9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU0Qsc0JBQXNCNEQsT0FBTztJQUNsQyxNQUFNLEVBQUVDLGlCQUFpQixFQUFFQyxlQUFlLEVBQUVDLFVBQVUsRUFBRSxHQUFHcEUsT0FBT3FFLE1BQU0sQ0FBQztRQUFFSCxtQkFBbUI7UUFBTUMsaUJBQWlCO1FBQU9DLFlBQVk7SUFBSyxHQUFHSDtJQUNoSjs7Ozs7O0tBTUMsR0FDRCxNQUFNSyxtQkFBbUIsQ0FBQ2hCO1FBQ3RCLE9BQU9pQixRQUFRLE9BQVFqQixPQUFPLFlBQWFhLENBQUFBLG1CQUFtQkssT0FBT0MsU0FBUyxDQUFDbkIsR0FBRSxLQUM1RSxPQUFPQSxPQUFPLFlBQWFZLENBQUFBLHFCQUFxQlosR0FBR29CLE1BQU0sR0FBRyxNQUM1RE4sY0FBY2QsT0FBTztJQUM5QjtJQUNBLE9BQU9nQjtBQUNYO0FBQ0FwRSw2QkFBNkIsR0FBR0c7QUFDaEM7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRCx1QkFBdUJ1RSxRQUFRLEVBQUVDLG9CQUFvQixLQUFLO0lBQy9ELE1BQU1DLGNBQWMsSUFBSUM7SUFDeEI7Ozs7Ozs7Ozs7S0FVQyxHQUNELFNBQVNDLHdCQUF3QjVFLEtBQUssRUFBRTZFLFVBQVU7UUFDOUMsSUFBSTdFLFVBQVU4RSxXQUFXO1lBQ3JCLE9BQU87Z0JBQUM7Z0JBQU87YUFBRTtRQUNyQixPQUNLLElBQUk5RSxVQUFVLE1BQU07WUFDckIsbUVBQW1FO1lBQ25FLE9BQU87Z0JBQUM7Z0JBQU02RSxhQUFhLElBQUk1QyxPQUFPOEMsUUFBUSxDQUFDQyxJQUFJO2FBQUM7UUFDeEQ7UUFDQSwrREFBK0Q7UUFDL0QsTUFBTUMsY0FBYyxPQUFPakY7UUFDM0IsSUFBSTtZQUNBLElBQUlpRixnQkFBZ0IsWUFBWTtnQkFDNUIsT0FBTztvQkFBQztvQkFBTztpQkFBRTtZQUNyQixPQUNLLElBQUlBLGdCQUFnQixZQUFZakYsaUJBQWlCa0YsUUFBUTtnQkFDMUQsT0FBTztvQkFDSDtvQkFDQUwsYUFDTSxJQUNBLENBQUMsR0FBRzVDLE9BQU9rRCxtQkFBbUIsRUFBRW5GLFNBQVNpQyxPQUFPOEMsUUFBUSxDQUFDSyxLQUFLLEdBQUc7aUJBQzFFO1lBQ0wsT0FDSyxJQUFJSCxnQkFBZ0IsYUFBYWpGLGlCQUFpQm9FLFNBQVM7Z0JBQzVELElBQUlTLFlBQVk7b0JBQ1osT0FBTzt3QkFBQzt3QkFBTTtxQkFBRTtnQkFDcEI7Z0JBQ0Esa0NBQWtDO2dCQUNsQyxPQUFPO29CQUFDO29CQUFNN0UsU0FBUyxPQUFPaUMsT0FBTzhDLFFBQVEsQ0FBQ00sSUFBSSxHQUFHcEQsT0FBTzhDLFFBQVEsQ0FBQ08sS0FBSztpQkFBQztZQUMvRSxPQUNLLElBQUlMLGdCQUFnQixZQUFZakYsaUJBQWlCcUUsUUFBUTtnQkFDMUQsSUFBSVEsWUFBWTtvQkFDWixPQUFPO3dCQUFDO3dCQUFNO3FCQUFFO2dCQUNwQjtnQkFDQSxPQUFPO29CQUFDO29CQUFPLElBQUc1QyxPQUFPc0QsbUJBQW1CLEVBQUV2RjtpQkFBTztZQUN6RCxPQUNLLElBQUlBLGlCQUFpQndGLE1BQU07Z0JBQzVCLElBQUlYLFlBQVk7b0JBQ1osT0FBTzt3QkFBQzt3QkFBTTtxQkFBRTtnQkFDcEI7Z0JBQ0EsT0FBTztvQkFDSDtvQkFDQSw2Q0FBNkM7b0JBQzdDWSxNQUFNekYsTUFBTTBGLE9BQU8sTUFDYnpELE9BQU84QyxRQUFRLENBQUNDLElBQUksR0FDcEIvQyxPQUFPOEMsUUFBUSxDQUFDUyxJQUFJLEdBQUd2RCxPQUFPOEMsUUFBUSxDQUFDSyxLQUFLLEdBQUc7aUJBQ3hEO1lBQ0w7UUFDSixFQUNBLE9BQU9PLEdBQUc7WUFDTixPQUFPO2dCQUFDO2dCQUFPO2FBQUU7UUFDckI7UUFDQSw0REFBNEQ7UUFDNUQsK0NBQStDO1FBQy9DLElBQUksQ0FBQyxDQUFDLEdBQUcxRCxPQUFPMkQsYUFBYSxFQUFFNUYsVUFBVSxDQUFDNkYsTUFBTUMsT0FBTyxDQUFDOUYsUUFBUTtZQUM1RCxPQUFPO2dCQUFDO2dCQUFPO2FBQUU7UUFDckI7UUFDQSx1Q0FBdUM7UUFDdkMsMENBQTBDO1FBQzFDLElBQUkwRSxZQUFZcUIsR0FBRyxDQUFDL0YsUUFBUTtZQUN4QixPQUFPO2dCQUFDO2dCQUFPO2FBQUU7UUFDckI7UUFDQSx5Q0FBeUM7UUFDekMsdUVBQXVFO1FBQ3ZFMEUsWUFBWXNCLEdBQUcsQ0FBQ2hHO1FBQ2hCLGdDQUFnQztRQUNoQyxJQUFJO1lBQ0EsT0FBTztnQkFDSDtnQkFDQUgsT0FBT29HLE9BQU8sQ0FBQ2pHLE9BQU9rRyxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxLQUFLQyxZQUFZLEVBQUVDLEtBQUtDO29CQUN4RCwyREFBMkQ7b0JBQzNELHdDQUF3QztvQkFDeEMsSUFBSSxDQUFDQyxPQUFPQyxLQUFLLEdBQUc3Qix3QkFBd0J5QixhQUFheEI7b0JBQ3pELElBQUksQ0FBQzJCLE9BQU87d0JBQ1IsTUFBTSxJQUFJRSxNQUFNO29CQUNwQjtvQkFDQSw0QkFBNEI7b0JBQzVCLHFFQUFxRTtvQkFDckUsb0VBQW9FO29CQUNwRWhDLFlBQVlpQyxNQUFNLENBQUMzRztvQkFDbkIsSUFBSTZFLFlBQVk7d0JBQ1osT0FBTztvQkFDWDtvQkFDQSxxREFBcUQ7b0JBQ3JELHVEQUF1RDtvQkFDdkQsTUFBTStCLFVBQVVmLE1BQU1DLE9BQU8sQ0FBQzlGLFNBQ3hCLElBQ0FvRyxJQUFJN0IsTUFBTSxHQUFHdEMsT0FBTzhDLFFBQVEsQ0FBQzhCLEtBQUssR0FBRzVFLE9BQU84QyxRQUFRLENBQUMrQixLQUFLLEdBQUc7b0JBQ25FLE1BQU1DLFlBQVlULE1BQU1DLElBQUloQyxNQUFNLEdBQUcsSUFBSXRDLE9BQU84QyxRQUFRLENBQUM4QixLQUFLLEdBQUc7b0JBQ2pFLE9BQU9WLE1BQU1TLFVBQVVILE9BQU9NO2dCQUNsQyxHQUNBLG1FQUFtRTtnQkFDbkUsK0JBQStCO2dCQUMvQmxDLGFBQWEsSUFBSTVDLE9BQU84QyxRQUFRLENBQUNpQyxPQUFPLEdBQUc7YUFDOUM7UUFDTCxFQUNBLE9BQU9yQixHQUFHO1lBQ04sT0FBTztnQkFBQztnQkFBTzthQUFFO1FBQ3JCO0lBQ0o7SUFDQSxPQUFPZix3QkFBd0JKLFVBQVVDO0FBQzdDO0FBQ0ExRSw4QkFBOEIsR0FBR0Usd0JBQ2pDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLmpzPzZjYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlSnNvbkFuZEdldFNpemUgPSBleHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmlzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9IGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBleHBvcnRzLmpzb25ycGMyID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IG1pc2NfMSA9IHJlcXVpcmUoXCIuL21pc2NcIik7XG5leHBvcnRzLkpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmUpKCdKc29uJywgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgW2lzVmFsaWRdID0gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiAnRXhwZWN0ZWQgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZSc7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGlzVmFsaWRKc29uO1xuLyoqXG4gKiBUaGUgc3RyaW5nICcyLjAnLlxuICovXG5leHBvcnRzLmpzb25ycGMyID0gJzIuMCc7XG5leHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoZXhwb3J0cy5qc29ucnBjMik7XG5leHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm51bGxhYmxlKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpXSkpO1xuZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBjb2RlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnRlZ2VyKSgpLFxuICAgIG1lc3NhZ2U6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBkYXRhOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uU3RydWN0KSxcbiAgICBzdGFjazogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLnJlY29yZCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBleHBvcnRzLkpzb25TdHJ1Y3QpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5hcnJheSkoZXhwb3J0cy5Kc29uU3RydWN0KV0pKTtcbmV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBtZXRob2Q6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBwYXJhbXM6IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub21pdCkoZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgWydpZCddKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0gT2JqZWN0LmFzc2lnbih7IHBlcm1pdEVtcHR5U3RyaW5nOiB0cnVlLCBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLCBwZXJtaXROdWxsOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBKU09OIHNlcmlhbGl6YWJsZSBhbmQgY291bnRzIHRoZSB0b3RhbCBudW1iZXJcbiAqIG9mIGJ5dGVzIG5lZWRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ganNPYmplY3QgLSBQb3RlbnRpYWwgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHBhcmFtIHNraXBTaXppbmdQcm9jZXNzIC0gU2tpcCBKU09OIHNpemUgY2FsY3VsYXRpb24gKGRlZmF1bHQ6IGZhbHNlKS5cbiAqIEByZXR1cm5zIFR1cGxlIFtpc1ZhbGlkLCBwbGFpblRleHRTaXplSW5CeXRlc10gY29udGFpbmluZyBhIGJvb2xlYW4gdGhhdCBzaWduYWxzIHdoZXRoZXJcbiAqIHRoZSB2YWx1ZSB3YXMgc2VyaWFsaXphYmxlIGFuZCBhIG51bWJlciBvZiBieXRlcyB0aGF0IGl0IHdpbGwgdXNlIHdoZW4gc2VyaWFsaXplZCB0byBKU09OLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUpzb25BbmRHZXRTaXplKGpzT2JqZWN0LCBza2lwU2l6aW5nUHJvY2VzcyA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBKU09OIHNlcmlhbGl6YWJsZSBhbmQgY291bnRzIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiBvZiBieXRlcyBuZWVkZWQgdG8gc3RvcmUgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIGVuY29kaW5nIG9mIHRoZSBKU09OIGlzIGRvbmUgaW4gVVRGLTguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBQb3RlbnRpYWwgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHNraXBTaXppbmcgLSBTa2lwIEpTT04gc2l6ZSBjYWxjdWxhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqIEByZXR1cm5zIFR1cGxlIFtpc1ZhbGlkLCBwbGFpblRleHRTaXplSW5CeXRlc10gY29udGFpbmluZyBhIGJvb2xlYW4gdGhhdCBzaWduYWxzIHdoZXRoZXJcbiAgICAgKiB0aGUgdmFsdWUgd2FzIHNlcmlhbGl6YWJsZSBhbmQgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBpdCB3aWxsIHVzZSB3aGVuIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyh2YWx1ZSwgc2tpcFNpemluZykge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhbHJlYWR5IHNwZWNpZmllZCBjb25zdGFudCBzaXplIGZvciBudWxsIChzcGVjaWFsIG9iamVjdClcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgc2tpcFNpemluZyA/IDAgOiBtaXNjXzEuSnNvblNpemUuTnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgYW5kIGNhbGN1bGF0ZSBzaXplcyBmb3IgYmFzaWMgKGFuZCBzb21lIHNwZWNpYWwpIHR5cGVzXG4gICAgICAgIGNvbnN0IHR5cGVPZlZhbHVlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVPZlZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwU2l6aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKDAsIG1pc2NfMS5jYWxjdWxhdGVTdHJpbmdTaXplKSh2YWx1ZSkgKyBtaXNjXzEuSnNvblNpemUuUXVvdGUgKiAyLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIHZhbHVlID09IHRydWUgPyBtaXNjXzEuSnNvblNpemUuVHJ1ZSA6IG1pc2NfMS5Kc29uU2l6ZS5GYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsICgwLCBtaXNjXzEuY2FsY3VsYXRlTnVtYmVyU2l6ZSkodmFsdWUpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEludmFsaWQgZGF0ZXMgd2lsbCBzZXJpYWxpemUgdG8gbnVsbFxuICAgICAgICAgICAgICAgICAgICBpc05hTih2YWx1ZS5nZXREYXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1pc2NfMS5Kc29uU2l6ZS5OdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1pc2NfMS5Kc29uU2l6ZS5EYXRlICsgbWlzY18xLkpzb25TaXplLlF1b3RlICogMixcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBvYmplY3QgaXMgbm90IHBsYWluIGFuZCBjYW5ub3QgYmUgc2VyaWFsaXplZCBwcm9wZXJseSxcbiAgICAgICAgLy8gc3RvcCBoZXJlIGFuZCByZXR1cm4gZmFsc2UgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKCEoMCwgbWlzY18xLmlzUGxhaW5PYmplY3QpKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENpcmN1bGFyIG9iamVjdCBkZXRlY3Rpb24gKGhhbmRsaW5nKVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2FtZSBvYmplY3QgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHNlZW5PYmplY3RzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBuZXcgb2JqZWN0IHRvIHRoZSBzZWVuIG9iamVjdHMgc2V0XG4gICAgICAgIC8vIE9ubHkgdGhlIHBsYWluIG9iamVjdHMgc2hvdWxkIGJlIGFkZGVkIChQcmltaXRpdmUgdHlwZXMgYXJlIHNraXBwZWQpXG4gICAgICAgIHNlZW5PYmplY3RzLmFkZCh2YWx1ZSk7XG4gICAgICAgIC8vIENvbnRpbnVlIG9iamVjdCBkZWNvbXBvc2l0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLnJlZHVjZSgoc3VtLCBba2V5LCBuZXN0ZWRWYWx1ZV0sIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgbmV4dCBuZXN0ZWQgb2JqZWN0IG9yIHByaW1pdGl2ZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgICAgICAgICAgbGV0IFt2YWxpZCwgc2l6ZV0gPSBnZXRKc29uU2VyaWFsaXphYmxlSW5mbyhuZXN0ZWRWYWx1ZSwgc2tpcFNpemluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTiB2YWxpZGF0aW9uIGRpZCBub3QgcGFzcy4gVmFsaWRhdGlvbiBwcm9jZXNzIHN0b3BwZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2lyY3VsYXIgb2JqZWN0IGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGEgY2hpbGQgbm9kZSBpcyB2aXNpdGVkIGFuZCBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIHdpdGggdGhlIHNhbWUgYWRqYWNlbnQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgc2Vlbk9iamVjdHMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgd2lsbCBoYXZlIGJlIHNlcmlhbGl6ZWQgd2l0aCBcImtleVwiOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmVmb3JlIHdlIGluY2x1ZGUgdGhlIGtleSBpbiB0aGUgY2FsY3VsYXRpb24gaGVyZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTaXplID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkubGVuZ3RoICsgbWlzY18xLkpzb25TaXplLkNvbW1hICsgbWlzY18xLkpzb25TaXplLkNvbG9uICogMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gaWR4IDwgYXJyLmxlbmd0aCAtIDEgPyBtaXNjXzEuSnNvblNpemUuQ29tbWEgOiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsga2V5U2l6ZSArIHNpemUgKyBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRzIGF0IDIgYmVjYXVzZSB0aGUgc2VyaWFsaXplZCBKU09OIHN0cmluZyBkYXRhIChwbGFpbiB0ZXh0KVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbWluaW1hbGx5IGNvbnRhaW4ge30vW11cbiAgICAgICAgICAgICAgICBza2lwU2l6aW5nID8gMCA6IG1pc2NfMS5Kc29uU2l6ZS5XcmFwcGVyICogMiksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8oanNPYmplY3QsIHNraXBTaXppbmdQcm9jZXNzKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVKc29uQW5kR2V0U2l6ZSA9IHZhbGlkYXRlSnNvbkFuZEdldFNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZhbGlkYXRlSnNvbkFuZEdldFNpemUiLCJnZXRKc29uUnBjSWRWYWxpZGF0b3IiLCJhc3NlcnRJc0pzb25ScGNFcnJvciIsImlzSnNvblJwY0Vycm9yIiwiYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSIsImlzSnNvblJwY0ZhaWx1cmUiLCJhc3NlcnRJc0pzb25ScGNTdWNjZXNzIiwiaXNKc29uUnBjU3VjY2VzcyIsImFzc2VydElzSnNvblJwY1Jlc3BvbnNlIiwiaXNKc29uUnBjUmVzcG9uc2UiLCJhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UiLCJpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UiLCJKc29uUnBjUmVzcG9uc2VTdHJ1Y3QiLCJKc29uUnBjRmFpbHVyZVN0cnVjdCIsIkpzb25ScGNTdWNjZXNzU3RydWN0IiwiUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCIsImFzc2VydElzSnNvblJwY1JlcXVlc3QiLCJpc0pzb25ScGNSZXF1ZXN0IiwiYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uIiwiaXNKc29uUnBjTm90aWZpY2F0aW9uIiwiSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCIsIkpzb25ScGNSZXF1ZXN0U3RydWN0IiwiSnNvblJwY1BhcmFtc1N0cnVjdCIsIkpzb25ScGNFcnJvclN0cnVjdCIsIkpzb25ScGNJZFN0cnVjdCIsIkpzb25ScGNWZXJzaW9uU3RydWN0IiwianNvbnJwYzIiLCJpc1ZhbGlkSnNvbiIsIkpzb25TdHJ1Y3QiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImFzc2VydF8xIiwibWlzY18xIiwiZGVmaW5lIiwiaXNWYWxpZCIsImlzIiwibGl0ZXJhbCIsIm51bGxhYmxlIiwidW5pb24iLCJudW1iZXIiLCJzdHJpbmciLCJvYmplY3QiLCJjb2RlIiwiaW50ZWdlciIsIm1lc3NhZ2UiLCJkYXRhIiwib3B0aW9uYWwiLCJzdGFjayIsInJlY29yZCIsImFycmF5IiwiaWQiLCJqc29ucnBjIiwibWV0aG9kIiwicGFyYW1zIiwib21pdCIsIkVycm9yV3JhcHBlciIsImFzc2VydFN0cnVjdCIsInJlc3VsdCIsInVua25vd24iLCJlcnJvciIsInJlc3BvbnNlIiwib3B0aW9ucyIsInBlcm1pdEVtcHR5U3RyaW5nIiwicGVybWl0RnJhY3Rpb25zIiwicGVybWl0TnVsbCIsImFzc2lnbiIsImlzVmFsaWRKc29uUnBjSWQiLCJCb29sZWFuIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibGVuZ3RoIiwianNPYmplY3QiLCJza2lwU2l6aW5nUHJvY2VzcyIsInNlZW5PYmplY3RzIiwiU2V0IiwiZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8iLCJza2lwU2l6aW5nIiwidW5kZWZpbmVkIiwiSnNvblNpemUiLCJOdWxsIiwidHlwZU9mVmFsdWUiLCJTdHJpbmciLCJjYWxjdWxhdGVTdHJpbmdTaXplIiwiUXVvdGUiLCJUcnVlIiwiRmFsc2UiLCJjYWxjdWxhdGVOdW1iZXJTaXplIiwiRGF0ZSIsImlzTmFOIiwiZ2V0RGF0ZSIsIl8iLCJpc1BsYWluT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiaGFzIiwiYWRkIiwiZW50cmllcyIsInJlZHVjZSIsInN1bSIsImtleSIsIm5lc3RlZFZhbHVlIiwiaWR4IiwiYXJyIiwidmFsaWQiLCJzaXplIiwiRXJyb3IiLCJkZWxldGUiLCJrZXlTaXplIiwiQ29tbWEiLCJDb2xvbiIsInNlcGFyYXRvciIsIldyYXBwZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/logging.js":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/logging.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)(\"metamask\");\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */ function createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */ function createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDaEUsTUFBTUksVUFBVVQsZ0JBQWdCVSxtQkFBT0EsQ0FBQyxzREFBTztBQUMvQyxNQUFNQyxlQUFlLENBQUMsR0FBR0YsUUFBUUcsT0FBTyxFQUFFO0FBQzFDOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0osb0JBQW9CSyxXQUFXO0lBQ3BDLE9BQU9GLGFBQWFHLE1BQU0sQ0FBQ0Q7QUFDL0I7QUFDQVIsMkJBQTJCLEdBQUdHO0FBQzlCOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTRCxtQkFBbUJRLGFBQWEsRUFBRUMsVUFBVTtJQUNqRCxPQUFPRCxjQUFjRCxNQUFNLENBQUNFO0FBQ2hDO0FBQ0FYLDBCQUEwQixHQUFHRSxvQkFDN0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuanM/ZjMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZ2xvYmFsTG9nZ2VyID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ21ldGFtYXNrJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkXG4gKiB1c2luZyB0aGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZVxuICogc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW0gYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgdG8gYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzIHRoYXRcbiAqIGFyZSBhbHNvIHVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZWlyIGxvZ2dlcnMuXG4gKlxuICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBUaGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZlxuICogeW91ciBOUE0gcGFja2FnZSBpZiB5b3UncmUgZGV2ZWxvcGluZyBvbmUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0TG9nZ2VyKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbExvZ2dlci5leHRlbmQocHJvamVjdE5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gY3JlYXRlUHJvamVjdExvZ2dlcjtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aGljaCBpcyBkZXJpdmVkIGZyb20gdGhlIGxvZ2dlciBmb3JcbiAqIHRoZSB3aG9sZSBwcm9qZWN0IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZCB1c2luZyB0aGUgbmFtZSBvZiB5b3VyXG4gKiBtb2R1bGUuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZSBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbVxuICogYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46PG1vZHVsZU5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gdGhlIHByb2plY3QsXG4gKiBvciBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdExvZ2dlciAtIFRoZSBsb2dnZXIgY3JlYXRlZCB2aWEge0BsaW5rIGNyZWF0ZVByb2plY3RMb2dnZXJ9LlxuICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIG1vZHVsZS4gWW91IGNvdWxkIHVzZSB0aGUgbmFtZSBvZiB0aGVcbiAqIGZpbGUgd2hlcmUgeW91J3JlIHVzaW5nIHRoaXMgbG9nZ2VyIG9yIHNvbWUgb3RoZXIgbmFtZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUxvZ2dlcihwcm9qZWN0TG9nZ2VyLCBtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIHByb2plY3RMb2dnZXIuZXh0ZW5kKG1vZHVsZU5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVNb2R1bGVMb2dnZXIiLCJjcmVhdGVQcm9qZWN0TG9nZ2VyIiwiZGVidWdfMSIsInJlcXVpcmUiLCJnbG9iYWxMb2dnZXIiLCJkZWZhdWx0IiwicHJvamVjdE5hbWUiLCJleHRlbmQiLCJwcm9qZWN0TG9nZ2VyIiwibW9kdWxlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/misc.js":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/misc.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */ function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */ function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */ const hasProperty = (objectToCheck, name)=>Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */ var JsonSize;\n(function(JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */ exports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */ function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */ function calculateStringSize(value) {\n    var _a;\n    const size = value.split(\"\").reduce((total, character)=>{\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */ function calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize; //# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLEVBQUU7QUFDRixRQUFRO0FBQ1IsRUFBRTtBQUNGQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHQSxlQUFlLEdBQUdBLHFCQUFxQixHQUFHQSxnQ0FBZ0MsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0EseUJBQXlCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDaFEsRUFBRTtBQUNGLGNBQWM7QUFDZCxFQUFFO0FBQ0Y7Ozs7OztDQU1DLEdBQ0QsU0FBU1csZ0JBQWdCVixLQUFLO0lBQzFCLE9BQU9XLE1BQU1DLE9BQU8sQ0FBQ1osVUFBVUEsTUFBTWEsTUFBTSxHQUFHO0FBQ2xEO0FBQ0FkLHVCQUF1QixHQUFHVztBQUMxQjs7Ozs7Q0FLQyxHQUNELFNBQVNELGtCQUFrQlQsS0FBSztJQUM1QixPQUFPQSxVQUFVLFFBQVFBLFVBQVVjO0FBQ3ZDO0FBQ0FmLHlCQUF5QixHQUFHVTtBQUM1Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxTQUFTUixLQUFLO0lBQ25CLE9BQU9lLFFBQVFmLFVBQVUsT0FBT0EsVUFBVSxZQUFZLENBQUNXLE1BQU1DLE9BQU8sQ0FBQ1o7QUFDekU7QUFDQUQsZ0JBQWdCLEdBQUdTO0FBQ25CLEVBQUU7QUFDRiwwQkFBMEI7QUFDMUIsRUFBRTtBQUNGOzs7Ozs7O0NBT0MsR0FDRCxNQUFNRCxjQUFjLENBQUNTLGVBQWVDLE9BQVNwQixPQUFPcUIsY0FBYyxDQUFDQyxJQUFJLENBQUNILGVBQWVDO0FBQ3ZGbEIsbUJBQW1CLEdBQUdRO0FBQ3RCOztDQUVDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbEMsd0RBQXdEO0lBQ3hEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQ3RDLEdBQUdBLFdBQVdQLFFBQVFPLFFBQVEsSUFBS1AsQ0FBQUEsZ0JBQWdCLEdBQUcsQ0FBQztBQUN2RDs7Q0FFQyxHQUNEQSxnQ0FBZ0MsR0FBRztBQUNuQzs7Ozs7O0NBTUMsR0FDRCxTQUFTSyxjQUFjSixLQUFLO0lBQ3hCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07UUFDN0MsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLElBQUlvQixRQUFRcEI7UUFDWixNQUFPSCxPQUFPd0IsY0FBYyxDQUFDRCxXQUFXLEtBQU07WUFDMUNBLFFBQVF2QixPQUFPd0IsY0FBYyxDQUFDRDtRQUNsQztRQUNBLE9BQU92QixPQUFPd0IsY0FBYyxDQUFDckIsV0FBV29CO0lBQzVDLEVBQ0EsT0FBT0UsR0FBRztRQUNOLE9BQU87SUFDWDtBQUNKO0FBQ0F2QixxQkFBcUIsR0FBR0s7QUFDeEI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxRQUFRb0IsU0FBUztJQUN0QixPQUFPQSxVQUFVQyxVQUFVLENBQUMsTUFBTTtBQUN0QztBQUNBekIsZUFBZSxHQUFHSTtBQUNsQjs7Ozs7Q0FLQyxHQUNELFNBQVNELG9CQUFvQkYsS0FBSztJQUM5QixJQUFJeUI7SUFDSixNQUFNQyxPQUFPMUIsTUFBTTJCLEtBQUssQ0FBQyxJQUFJQyxNQUFNLENBQUMsQ0FBQ0MsT0FBT047UUFDeEMsSUFBSXBCLFFBQVFvQixZQUFZO1lBQ3BCLE9BQU9NLFFBQVE7UUFDbkI7UUFDQSxPQUFPQSxRQUFRO0lBQ25CLEdBQUc7SUFDSCxvREFBb0Q7SUFDcEQsT0FBT0gsT0FBTyxDQUFDLENBQUNELEtBQUt6QixNQUFNOEIsS0FBSyxDQUFDL0IsUUFBUU0sd0JBQXdCLE9BQU8sUUFBUW9CLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsRUFBRVosTUFBTTtBQUNuSDtBQUNBZCwyQkFBMkIsR0FBR0c7QUFDOUI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxvQkFBb0JELEtBQUs7SUFDOUIsT0FBT0EsTUFBTStCLFFBQVEsR0FBR2xCLE1BQU07QUFDbEM7QUFDQWQsMkJBQTJCLEdBQUdFLHFCQUM5QixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcz85NGM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy9cbi8vIFR5cGVzXG4vL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gZXhwb3J0cy5pc0FTQ0lJID0gZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSBleHBvcnRzLkpzb25TaXplID0gZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSB2b2lkIDA7XG4vL1xuLy8gVHlwZSBHdWFyZHNcbi8vXG4vKipcbiAqIEEge0BsaW5rIE5vbkVtcHR5QXJyYXl9IHR5cGUgZ3VhcmQuXG4gKlxuICogQHRlbXBsYXRlIEVsZW1lbnQgLSBUaGUgbm9uLWVtcHR5IGFycmF5IG1lbWJlciB0eXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIFwibnVsbGlzaG5lc3NcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciB7QGxpbmsgUnVudGltZU9iamVjdH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGhhcyBhIHJ1bnRpbWUgdHlwZSBvZiBgb2JqZWN0YCBhbmQgaXNcbiAqIG5laXRoZXIgYG51bGxgIG5vciBhbiBgQXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vXG4vLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9uc1xuLy9cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlbnN1cmluZyBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBuYW1lLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgZW51bWVyYWJsZSBvciBub3QuXG4gKi9cbmNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iamVjdFRvQ2hlY2ssIG5hbWUpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIG5hbWUpO1xuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5O1xuLyoqXG4gKiBQcmVkZWZpbmVkIHNpemVzIChpbiBCeXRlcykgb2Ygc3BlY2lmaWMgcGFydHMgb2YgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbnZhciBKc29uU2l6ZTtcbihmdW5jdGlvbiAoSnNvblNpemUpIHtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIk51bGxcIl0gPSA0XSA9IFwiTnVsbFwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29tbWFcIl0gPSAxXSA9IFwiQ29tbWFcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIldyYXBwZXJcIl0gPSAxXSA9IFwiV3JhcHBlclwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiVHJ1ZVwiXSA9IDRdID0gXCJUcnVlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJGYWxzZVwiXSA9IDVdID0gXCJGYWxzZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiUXVvdGVcIl0gPSAxXSA9IFwiUXVvdGVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbG9uXCJdID0gMV0gPSBcIkNvbG9uXCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkRhdGVcIl0gPSAyNF0gPSBcIkRhdGVcIjtcbn0pKEpzb25TaXplID0gZXhwb3J0cy5Kc29uU2l6ZSB8fCAoZXhwb3J0cy5Kc29uU2l6ZSA9IHt9KSk7XG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIChzcGVjaWFsKSBlc2NhcGVkIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1wifFxcXFx8XFxufFxccnxcXHQvZ3U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbi8qKlxuICogQ2hlY2sgaWYgY2hhcmFjdGVyIGlzIEFTQ0lJLlxuICpcbiAqIEBwYXJhbSBjaGFyYWN0ZXIgLSBDaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGEgY2hhcmFjdGVyIGNvZGUgaXMgQVNDSUksIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSShjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMTI3O1xufVxuZXhwb3J0cy5pc0FTQ0lJID0gaXNBU0NJSTtcbi8qKlxuICogQ2FsY3VsYXRlIHN0cmluZyBzaXplLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIHN0cmluZyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3RyaW5nU2l6ZSh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoaXNBU0NJSShjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDI7XG4gICAgfSwgMCk7XG4gICAgLy8gQWxzbyBkZXRlY3QgY2hhcmFjdGVycyB0aGF0IG5lZWQgYmFja3NsYXNoIGVzY2FwZVxuICAgIHJldHVybiBzaXplICsgKChfYSA9IHZhbHVlLm1hdGNoKGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNhbGN1bGF0ZU51bWJlclNpemUiLCJjYWxjdWxhdGVTdHJpbmdTaXplIiwiaXNBU0NJSSIsImlzUGxhaW5PYmplY3QiLCJFU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAiLCJKc29uU2l6ZSIsImhhc1Byb3BlcnR5IiwiaXNPYmplY3QiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTm9uRW1wdHlBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVuZGVmaW5lZCIsIkJvb2xlYW4iLCJvYmplY3RUb0NoZWNrIiwibmFtZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJfIiwiY2hhcmFjdGVyIiwiY2hhckNvZGVBdCIsIl9hIiwic2l6ZSIsInNwbGl0IiwicmVkdWNlIiwidG90YWwiLCJtYXRjaCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/number.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/number.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.js\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */ const numberToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToHex` instead.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */ const bigIntToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative bigint.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */ const hexToNumber = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), \"Value is not a safe integer. Use `hexToBigInt` instead.\");\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */ const hexToBigInt = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt; //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBRyxLQUFLO0FBQzdGLE1BQU1NLFdBQVdDLG1CQUFPQSxDQUFDLHFFQUFVO0FBQ25DLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLCtEQUFPO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0QsTUFBTUYsY0FBYyxDQUFDSjtJQUNoQixJQUFHSyxTQUFTRyxNQUFNLEVBQUUsT0FBT1IsVUFBVSxVQUFVO0lBQy9DLElBQUdLLFNBQVNHLE1BQU0sRUFBRVIsU0FBUyxHQUFHO0lBQ2hDLElBQUdLLFNBQVNHLE1BQU0sRUFBRUMsT0FBT0MsYUFBYSxDQUFDVixRQUFRO0lBQ2xELE9BQU8sQ0FBQyxHQUFHTyxNQUFNSSxLQUFLLEVBQUVYLE1BQU1ZLFFBQVEsQ0FBQztBQUMzQztBQUNBYixtQkFBbUIsR0FBR0s7QUFDdEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUQsY0FBYyxDQUFDSDtJQUNoQixJQUFHSyxTQUFTRyxNQUFNLEVBQUUsT0FBT1IsVUFBVSxVQUFVO0lBQy9DLElBQUdLLFNBQVNHLE1BQU0sRUFBRVIsU0FBUyxHQUFHO0lBQ2pDLE9BQU8sQ0FBQyxHQUFHTyxNQUFNSSxLQUFLLEVBQUVYLE1BQU1ZLFFBQVEsQ0FBQztBQUMzQztBQUNBYixtQkFBbUIsR0FBR0k7QUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELE1BQU1ELGNBQWMsQ0FBQ0Y7SUFDaEIsSUFBR08sTUFBTU0saUJBQWlCLEVBQUViO0lBQzdCLDJFQUEyRTtJQUMzRSxrRUFBa0U7SUFDbEUsTUFBTWMsY0FBY0MsU0FBU2YsT0FBTztJQUNuQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVDLE9BQU9DLGFBQWEsQ0FBQ0ksY0FBYztJQUN4RCxPQUFPQTtBQUNYO0FBQ0FmLG1CQUFtQixHQUFHRztBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNRCxjQUFjLENBQUNEO0lBQ2hCLElBQUdPLE1BQU1NLGlCQUFpQixFQUFFYjtJQUM3QiwyRUFBMkU7SUFDM0UsT0FBT2dCLE9BQU8sQ0FBQyxHQUFHVCxNQUFNSSxLQUFLLEVBQUVYO0FBQ25DO0FBQ0FELG1CQUFtQixHQUFHRSxhQUN0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzP2RjMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8qKlxuICogQ29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBudW1iZXIgaXMgYVxuICogbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBudW1iZXJUb0hleCgwKTsgLy8gJzB4MCdcbiAqIG51bWJlclRvSGV4KDEpOyAvLyAnMHgxJ1xuICogbnVtYmVyVG9IZXgoMTYpOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBudW1iZXJUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9IZXhgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLm51bWJlclRvSGV4ID0gbnVtYmVyVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBgYmlnaW50YFxuICogaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZSB7QGxpbmsgbnVtYmVyVG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBiaWdJbnRUb0hleCgwbik7IC8vICcweDAnXG4gKiBiaWdJbnRUb0hleCgxbik7IC8vICcweDEnXG4gKiBiaWdJbnRUb0hleCgxNm4pOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgYGJpZ2ludGAgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGJpZ0ludFRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5iaWdJbnRUb0hleCA9IGJpZ0ludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpcyBhXG4gKiB2YWxpZCBoZXggc3RyaW5nLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBhIHNhZmUgaW50ZWdlci4gQm90aFxuICogXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgaGV4VG9CaWdJbnR9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb051bWJlcignMHgwJyk7IC8vIDBcbiAqIGhleFRvTnVtYmVyKCcweDEnKTsgLy8gMVxuICogaGV4VG9OdW1iZXIoJzB4MTAnKTsgLy8gMTZcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZywgb3IgaWYgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgaGV4VG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBgcGFyc2VJbnRgIGFjY2VwdHMgdmFsdWVzIHdpdGhvdXQgdGhlIFwiMHhcIi1wcmVmaXgsIHdoZXJlYXMgYE51bWJlcmAgZG9lc1xuICAgIC8vIG5vdC4gVXNpbmcgdGhpcyBpcyBzbGlnaHRseSBmYXN0ZXIgdGhhbiBgTnVtYmVyKGFkZDB4KHZhbHVlKSlgLlxuICAgIGNvbnN0IG51bWJlclZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXJWYWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgaGV4VG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIG51bWJlclZhbHVlO1xufTtcbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpc1xuICogYSB2YWxpZCBoZXggc3RyaW5nLiBCb3RoIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlciBpbnN0ZWFkLCB1c2Uge0BsaW5rIGhleFRvTnVtYmVyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9CaWdJbnQoJzB4MCcpOyAvLyAwblxuICogaGV4VG9CaWdJbnQoJzB4MScpOyAvLyAxblxuICogaGV4VG9CaWdJbnQoJzB4MTAnKTsgLy8gMTZuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5jb25zdCBoZXhUb0JpZ0ludCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciByZXF1aXJlcyB0aGUgXCIweFwiLXByZWZpeCB0byBwYXJzZSBhIGhleCBzdHJpbmcuXG4gICAgcmV0dXJuIEJpZ0ludCgoMCwgaGV4XzEuYWRkMHgpKHZhbHVlKSk7XG59O1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGhleFRvQmlnSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhleFRvQmlnSW50IiwiaGV4VG9OdW1iZXIiLCJiaWdJbnRUb0hleCIsIm51bWJlclRvSGV4IiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiaGV4XzEiLCJhc3NlcnQiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiYWRkMHgiLCJ0b1N0cmluZyIsImFzc2VydElzSGV4U3RyaW5nIiwibnVtYmVyVmFsdWUiLCJwYXJzZUludCIsIkJpZ0ludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/opaque.js":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/opaque.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=opaque.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qvb3BhcXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDLEVBQzdELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuanM/ODU2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wYXF1ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/opaque.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/time.js":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/time.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */ var Duration;\n(function(Duration) {\n    /**\n     * A millisecond.\n     */ Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */ Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */ Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */ Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */ Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */ Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */ Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number)=>Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name)=>{\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */ function inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, \"count\");\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */ function timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, \"timestamp\");\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince; //# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLHNCQUFzQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3JFOztDQUVDLEdBQ0QsSUFBSUk7QUFDSCxVQUFVQSxRQUFRO0lBQ2Y7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUN4Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsS0FBSyxHQUFHO0lBQ3RDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxNQUFNLEdBQUc7SUFDdkM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLFFBQVEsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxNQUFNLEdBQUcsU0FBUyxHQUFHO0lBQ3ZDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxVQUFVLEdBQUc7SUFDekM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLFlBQVksR0FBRztBQUMvQyxHQUFHQSxXQUFXSixRQUFRSSxRQUFRLElBQUtKLENBQUFBLGdCQUFnQixHQUFHLENBQUM7QUFDdkQsTUFBTUssdUJBQXVCLENBQUNDLFNBQVdDLE9BQU9DLFNBQVMsQ0FBQ0YsV0FBV0EsVUFBVTtBQUMvRSxNQUFNRyw2QkFBNkIsQ0FBQ0gsUUFBUUk7SUFDeEMsSUFBSSxDQUFDTCxxQkFBcUJDLFNBQVM7UUFDL0IsTUFBTSxJQUFJSyxNQUFNLENBQUMsQ0FBQyxFQUFFRCxLQUFLLDZDQUE2QyxFQUFFSixPQUFPLEVBQUUsQ0FBQztJQUN0RjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU0gsZUFBZVMsS0FBSyxFQUFFQyxRQUFRO0lBQ25DSiwyQkFBMkJHLE9BQU87SUFDbEMsT0FBT0EsUUFBUUM7QUFDbkI7QUFDQWIsc0JBQXNCLEdBQUdHO0FBQ3pCOzs7OztDQUtDLEdBQ0QsU0FBU0QsVUFBVVksU0FBUztJQUN4QkwsMkJBQTJCSyxXQUFXO0lBQ3RDLE9BQU9DLEtBQUtDLEdBQUcsS0FBS0Y7QUFDeEI7QUFDQWQsaUJBQWlCLEdBQUdFLFdBQ3BCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC90aW1lLmpzP2VkMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRpbWVTaW5jZSIsImluTWlsbGlzZWNvbmRzIiwiRHVyYXRpb24iLCJpc05vbk5lZ2F0aXZlSW50ZWdlciIsIm51bWJlciIsIk51bWJlciIsImlzSW50ZWdlciIsImFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyIiwibmFtZSIsIkVycm9yIiwiY291bnQiLCJkdXJhdGlvbiIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/versions.js":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/versions.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct for validating a version string.\n */ exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version\", (value)=>{\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version range\", (value)=>{\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */ function isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */ function isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */ function assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */ function assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */ function gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */ function gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */ function satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange; //# sourceMappingURL=versions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdmVyc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHQSwyQkFBMkIsR0FBR0EsNkJBQTZCLEdBQUdBLDBCQUEwQixHQUFHQSw0QkFBNEIsR0FBR0EsMEJBQTBCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDMVAsTUFBTVcsV0FBV0MsbUJBQU9BLENBQUMsb0RBQVE7QUFDakMsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxpR0FBYTtBQUMzQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxxRUFBVTtBQUNuQzs7Q0FFQyxHQUNEWixxQkFBcUIsR0FBRyxDQUFDLEdBQUdhLGNBQWNFLE1BQU0sRUFBRSxDQUFDLEdBQUdGLGNBQWNHLE1BQU0sS0FBSyxXQUFXLENBQUNmO0lBQ3ZGLElBQUksQ0FBQyxHQUFHVSxTQUFTTSxLQUFLLEVBQUVoQixXQUFXLE1BQU07UUFDckMsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUNwRDtJQUNBLE9BQU87QUFDWDtBQUNBRCwwQkFBMEIsR0FBRyxDQUFDLEdBQUdhLGNBQWNFLE1BQU0sRUFBRSxDQUFDLEdBQUdGLGNBQWNHLE1BQU0sS0FBSyxpQkFBaUIsQ0FBQ2Y7SUFDbEcsSUFBSSxDQUFDLEdBQUdVLFNBQVNPLFVBQVUsRUFBRWpCLFdBQVcsTUFBTTtRQUMxQyxPQUFPLENBQUMsNEJBQTRCLEVBQUVBLE1BQU0sQ0FBQyxDQUFDO0lBQ2xEO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTTyxxQkFBcUJXLE9BQU87SUFDakMsT0FBTyxDQUFDLEdBQUdOLGNBQWNPLEVBQUUsRUFBRUQsU0FBU25CLFFBQVFVLGFBQWE7QUFDL0Q7QUFDQVYsNEJBQTRCLEdBQUdRO0FBQy9COzs7OztDQUtDLEdBQ0QsU0FBU0QsbUJBQW1CYyxZQUFZO0lBQ3BDLE9BQU8sQ0FBQyxHQUFHUixjQUFjTyxFQUFFLEVBQUVDLGNBQWNyQixRQUFRUyxrQkFBa0I7QUFDekU7QUFDQVQsMEJBQTBCLEdBQUdPO0FBQzdCOzs7O0NBSUMsR0FDRCxTQUFTRCxzQkFBc0JhLE9BQU87SUFDakMsSUFBR0wsU0FBU1EsWUFBWSxFQUFFSCxTQUFTbkIsUUFBUVUsYUFBYTtBQUM3RDtBQUNBViw2QkFBNkIsR0FBR007QUFDaEM7Ozs7Q0FJQyxHQUNELFNBQVNELG9CQUFvQmtCLEtBQUs7SUFDN0IsSUFBR1QsU0FBU1EsWUFBWSxFQUFFQyxPQUFPdkIsUUFBUVMsa0JBQWtCO0FBQ2hFO0FBQ0FULDJCQUEyQixHQUFHSztBQUM5Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxVQUFVb0IsUUFBUSxFQUFFQyxRQUFRO0lBQ2pDLE9BQU8sQ0FBQyxHQUFHZCxTQUFTZSxFQUFFLEVBQUVGLFVBQVVDO0FBQ3RDO0FBQ0F6QixpQkFBaUIsR0FBR0k7QUFDcEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsUUFBUWdCLE9BQU8sRUFBRUksS0FBSztJQUMzQixPQUFPLENBQUMsR0FBR1osU0FBU2dCLEdBQUcsRUFBRVIsU0FBU0k7QUFDdEM7QUFDQXZCLGVBQWUsR0FBR0c7QUFDbEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsc0JBQXNCaUIsT0FBTyxFQUFFRSxZQUFZO0lBQ2hELE9BQU8sQ0FBQyxHQUFHVixTQUFTaUIsU0FBUyxFQUFFVCxTQUFTRSxjQUFjO1FBQ2xEUSxtQkFBbUI7SUFDdkI7QUFDSjtBQUNBN0IsNkJBQTZCLEdBQUdFLHVCQUNoQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdmVyc2lvbnMuanM/ZDllYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc2VtdmVyXzEgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBBIHN0cnVjdCBmb3IgdmFsaWRhdGluZyBhIHZlcnNpb24gc3RyaW5nLlxuICovXG5leHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24nLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgdmVyc2lvbiwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG5leHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbiByYW5nZScsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWRSYW5nZSkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHJhbmdlLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBpc1ZhbGlkU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiByYW5nZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gQSBwb3RlbnRpYWwgdmVyc2lvbiByYW5nZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiByYW5nZSBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyUmFuZ2UodmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uUmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gaXNWYWxpZFNlbVZlclJhbmdlO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGNvbmNyZXRlIFNlbVZlciB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgU2VtVmVyIGNvbmNyZXRlIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gcmFuZ2UgLSBBIHBvdGVudGlhbCBTZW1WZXIgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyUmFuZ2UocmFuZ2UpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gYXNzZXJ0SXNTZW1WZXJSYW5nZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbjEgLSBUaGUgbGVmdC1oYW5kIHZlcnNpb24uXG4gKiBAcGFyYW0gdmVyc2lvbjIgLSBUaGUgcmlnaHQtaGFuZCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHZlcnNpb24xID4gdmVyc2lvbjJgLlxuICovXG5mdW5jdGlvbiBndFZlcnNpb24odmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndCkodmVyc2lvbjEsIHZlcnNpb24yKTtcbn1cbmV4cG9ydHMuZ3RWZXJzaW9uID0gZ3RWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgcG9zc2liaWxpdGllcyBpbiBhIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBTZW12VmVyIHZlcnNpb24uXG4gKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uID4gcmFuZ2VgLlxuICovXG5mdW5jdGlvbiBndFJhbmdlKHZlcnNpb24sIHJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndHIpKHZlcnNpb24sIHJhbmdlKTtcbn1cbmV4cG9ydHMuZ3RSYW5nZSA9IGd0UmFuZ2U7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHNhdGlzZmllcyBhIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBTZW1WZXIgdmVyc2lvbiB0byBjaGVjay5cbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBUaGUgU2VtVmVyIHZlcnNpb24gcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZlcnNpb24gc2F0aXNmaWVkIHRoZSB2ZXJzaW9uIHJhbmdlLlxuICovXG5mdW5jdGlvbiBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2UodmVyc2lvbiwgdmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5zYXRpc2ZpZXMpKHZlcnNpb24sIHZlcnNpb25SYW5nZSwge1xuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gc2F0aXNmaWVzVmVyc2lvblJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2F0aXNmaWVzVmVyc2lvblJhbmdlIiwiZ3RSYW5nZSIsImd0VmVyc2lvbiIsImFzc2VydElzU2VtVmVyUmFuZ2UiLCJhc3NlcnRJc1NlbVZlclZlcnNpb24iLCJpc1ZhbGlkU2VtVmVyUmFuZ2UiLCJpc1ZhbGlkU2VtVmVyVmVyc2lvbiIsIlZlcnNpb25SYW5nZVN0cnVjdCIsIlZlcnNpb25TdHJ1Y3QiLCJzZW12ZXJfMSIsInJlcXVpcmUiLCJzdXBlcnN0cnVjdF8xIiwiYXNzZXJ0XzEiLCJyZWZpbmUiLCJzdHJpbmciLCJ2YWxpZCIsInZhbGlkUmFuZ2UiLCJ2ZXJzaW9uIiwiaXMiLCJ2ZXJzaW9uUmFuZ2UiLCJhc3NlcnRTdHJ1Y3QiLCJyYW5nZSIsInZlcnNpb24xIiwidmVyc2lvbjIiLCJndCIsImd0ciIsInNhdGlzZmllcyIsImluY2x1ZGVQcmVyZWxlYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/versions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null) this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            return cached ?? (cached = [\n                failure,\n                ...failures()\n            ]);\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    if (typeof value === \"symbol\") {\n        return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = \"valid\";\n    for (const failure of struct.validator(value, ctx)){\n        failure.explanation = options.message;\n        status = \"not_valid\";\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask,\n            message: options.message\n        });\n        for (const t of ts){\n            if (t[0]) {\n                status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    if (v !== undefined || k in value) value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== \"not_valid\") {\n        for (const failure of struct.refiner(value, ctx)){\n            failure.explanation = options.message;\n            status = \"not_refined\";\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (status === \"valid\") {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */ assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */ create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */ is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */ mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct, message) {\n    const result = validate(value, struct, {\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const schema = struct instanceof Struct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || `Expected a function, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value) {\n            for (const S of Structs){\n                const [error, coerced] = S.validate(value, {\n                    coerce: true\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUNEOzs7Ozs7O0NBT0MsR0FDRCxNQUFNQSxvQkFBb0JDO0lBQ3RCQyxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJQztRQUNKLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUUsR0FBR0MsTUFBTSxHQUFHTDtRQUMxQyxNQUFNLEVBQUVNLElBQUksRUFBRSxHQUFHTjtRQUNqQixNQUFNTyxNQUFNRCxLQUFLRSxNQUFNLEtBQUssSUFBSUwsVUFBVSxDQUFDLFNBQVMsRUFBRUcsS0FBS0csSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFTixRQUFRLENBQUM7UUFDcEYsS0FBSyxDQUFDQyxlQUFlRztRQUNyQixJQUFJSCxlQUFlLE1BQ2YsSUFBSSxDQUFDTSxLQUFLLEdBQUdIO1FBQ2pCSSxPQUFPQyxNQUFNLENBQUMsSUFBSSxFQUFFUDtRQUNwQixJQUFJLENBQUNRLElBQUksR0FBRyxJQUFJLENBQUNkLFdBQVcsQ0FBQ2MsSUFBSTtRQUNqQyxJQUFJLENBQUNaLFFBQVEsR0FBRztZQUNaLE9BQVFDLFVBQVdBLENBQUFBLFNBQVM7Z0JBQUNGO21CQUFZQzthQUFXO1FBQ3hEO0lBQ0o7QUFDSjtBQUVBOztDQUVDLEdBQ0QsU0FBU2EsV0FBV0MsQ0FBQztJQUNqQixPQUFPQyxTQUFTRCxNQUFNLE9BQU9BLENBQUMsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDLEtBQUs7QUFDeEQ7QUFDQTs7Q0FFQyxHQUNELFNBQVNGLFNBQVNELENBQUM7SUFDZixPQUFPLE9BQU9BLE1BQU0sWUFBWUEsS0FBSztBQUN6QztBQUNBOztDQUVDLEdBQ0QsU0FBU0ksY0FBY0osQ0FBQztJQUNw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RSxNQUFNO1lBQ3BELE9BQVEsT0FBUTVFLFNBQVNBLFNBQVMyRyxPQUM5QixDQUFDLEVBQUUwQixTQUFTLENBQUMsRUFBRUMsR0FBRyxnQkFBZ0IsRUFBRXRJLE1BQU0sRUFBRSxDQUFDO1FBQ3JELE9BQ0ssSUFBSUEsaUJBQWlCbUMsT0FBT25DLGlCQUFpQnFDLEtBQUs7WUFDbkQsTUFBTSxFQUFFdUYsSUFBSSxFQUFFLEdBQUc1SDtZQUNqQixPQUFRLE9BQVE0SCxRQUFRQSxRQUFRakIsT0FDNUIsQ0FBQyxFQUFFMEIsU0FBUyxhQUFhLEVBQUVDLEdBQUcsbUNBQW1DLEVBQUVWLEtBQUssRUFBRSxDQUFDO1FBQ25GLE9BQ0s7WUFDRCxNQUFNLEVBQUU3SSxNQUFNLEVBQUUsR0FBR2lCO1lBQ25CLE9BQVEsT0FBUWpCLFVBQVVBLFVBQVU0SCxPQUNoQyxDQUFDLEVBQUUwQixTQUFTLGVBQWUsRUFBRUMsR0FBRyxxQ0FBcUMsRUFBRXZKLE9BQU8sRUFBRSxDQUFDO1FBQ3pGO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVM0SSxPQUFPaEgsTUFBTSxFQUFFdkIsSUFBSSxFQUFFbUQsT0FBTztJQUNqQyxPQUFPLElBQUlDLE9BQU87UUFDZCxHQUFHN0IsTUFBTTtRQUNULENBQUM0QixTQUFRdkMsS0FBSyxFQUFFc0IsR0FBRztZQUNmLE9BQU9YLE9BQU80QixPQUFPLENBQUN2QyxPQUFPc0I7WUFDN0IsTUFBTWIsU0FBUzhCLFFBQVF2QyxPQUFPc0I7WUFDOUIsTUFBTTlDLFdBQVd3QyxXQUFXUCxRQUFRYSxLQUFLWCxRQUFRWDtZQUNqRCxLQUFLLE1BQU16QixXQUFXQyxTQUFVO2dCQUM1QixNQUFNO29CQUFFLEdBQUdELE9BQU87b0JBQUV1QyxZQUFZMUI7Z0JBQUs7WUFDekM7UUFDSjtJQUNKO0FBQ0o7QUFFNlosQ0FDN1osa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvZGlzdC9pbmRleC5tanM/OWFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICovXG4vKipcbiAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIFZhbGlkYXRpb24gbG9naWMgaXMgZGVzaWduIHRvIGV4aXQgZWFybHkgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UuIFRoZSBlcnJvclxuICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAqIHRoZSBgZXJyb3IuZmFpbHVyZXNgIHByb3BlcnR5IGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0b1xuICogY29udGludWUgdmFsaWRhdGlvbiBhbmQgcmVjZWl2ZSBhbGwgdGhlIGZhaWx1cmVzIGluIHRoZSBkYXRhLlxuICovXG5jbGFzcyBTdHJ1Y3RFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmFpbHVyZSwgZmFpbHVyZXMpIHtcbiAgICAgICAgbGV0IGNhY2hlZDtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBleHBsYW5hdGlvbiwgLi4ucmVzdCB9ID0gZmFpbHVyZTtcbiAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBmYWlsdXJlO1xuICAgICAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBgQXQgcGF0aDogJHtwYXRoLmpvaW4oJy4nKX0gLS0gJHttZXNzYWdlfWA7XG4gICAgICAgIHN1cGVyKGV4cGxhbmF0aW9uID8/IG1zZyk7XG4gICAgICAgIGlmIChleHBsYW5hdGlvbiAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG1zZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjYWNoZWQgPz8gKGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHgpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbi8qKlxuICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGAke3ZhbHVlfWA7XG59XG4vKipcbiAqIFNoaWZ0cyAocmVtb3ZlcyBhbmQgcmV0dXJucykgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICovXG5mdW5jdGlvbiBzaGlmdEl0ZXJhdG9yKGlucHV0KSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gaW5wdXQubmV4dCgpO1xuICAgIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICovXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgbWVzc2FnZTogcmVzdWx0IH07XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gc3RydWN0O1xuICAgIGNvbnN0IHsgcmVmaW5lbWVudCwgbWVzc2FnZSA9IGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXFxgJHt0eXBlfVxcYCR7cmVmaW5lbWVudCA/IGAgd2l0aCByZWZpbmVtZW50IFxcYCR7cmVmaW5lbWVudH1cXGBgIDogJyd9LCBidXQgcmVjZWl2ZWQ6IFxcYCR7cHJpbnQodmFsdWUpfVxcYGAsIH0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlZmluZW1lbnQsXG4gICAgICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgICAgICBwYXRoLFxuICAgICAgICBicmFuY2gsXG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gKi9cbmZ1bmN0aW9uKiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgIGlmICghaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IGZhaWx1cmUgPSB0b0ZhaWx1cmUociwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICB5aWVsZCBmYWlsdXJlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHRyYXZlcnNpbmcgZGVlcGx5IGludG8gbmVzdGVkIHZhbHVlcywgYW5kXG4gKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqL1xuZnVuY3Rpb24qIHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHBhdGggPSBbXSwgYnJhbmNoID0gW3ZhbHVlXSwgY29lcmNlID0gZmFsc2UsIG1hc2sgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjdHggPSB7IHBhdGgsIGJyYW5jaCB9O1xuICAgIGlmIChjb2VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgaWYgKG1hc2sgJiZcbiAgICAgICAgICAgIHN0cnVjdC50eXBlICE9PSAndHlwZScgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmXG4gICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGF0dXMgPSAndmFsaWQnO1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgIGNvbnN0IHRzID0gcnVuKHYsIHMsIHtcbiAgICAgICAgICAgIHBhdGg6IGsgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwga10sXG4gICAgICAgICAgICBicmFuY2g6IGsgPT09IHVuZGVmaW5lZCA/IGJyYW5jaCA6IFsuLi5icmFuY2gsIHZdLFxuICAgICAgICAgICAgY29lcmNlLFxuICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0WzBdLnJlZmluZW1lbnQgIT0gbnVsbCA/ICdub3RfcmVmaW5lZCcgOiAnbm90X3ZhbGlkJztcbiAgICAgICAgICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgICAgIHYgPSB0WzFdO1xuICAgICAgICAgICAgICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zZXQoaywgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmFkZCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgfHwgayBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXR1cyAhPT0gJ25vdF92YWxpZCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICAgICAgc3RhdHVzID0gJ25vdF9yZWZpbmVkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5jbGFzcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgc2NoZW1hLCB2YWxpZGF0b3IsIHJlZmluZXIsIGNvZXJjZXIgPSAodmFsdWUpID0+IHZhbHVlLCBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHsgfSwgfSA9IHByb3BzO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcbiAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmaW5lciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAqL1xuICAgIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAgICovXG4gICAgY3JlYXRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLlxuICAgICAqL1xuICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgd2l0aENvZXJjaW9uYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICovXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUsIG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgIH1cbn1cbi8qKlxuICogTWFzayBhIHZhbHVlLCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgZGVmaW5lZCBieSBhIHN0cnVjdC5cbiAqL1xuZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUsIG1hc2s6IHRydWUsIG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcbiAgICByZXR1cm4gIXJlc3VsdFswXTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCByZXR1cm5pbmcgYW4gZXJyb3IgaWYgaW52YWxpZCwgb3IgdGhlXG4gKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdHVwbGUgPSBzaGlmdEl0ZXJhdG9yKHR1cGxlcyk7XG4gICAgaWYgKHR1cGxlWzBdKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHR1cGxlcykge1xuICAgICAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHYgPSB0dXBsZVsxXTtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHZdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduKC4uLlN0cnVjdHMpIHtcbiAgICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJztcbiAgICBjb25zdCBzY2hlbWFzID0gU3RydWN0cy5tYXAoKHMpID0+IHMuc2NoZW1hKTtcbiAgICBjb25zdCBzY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zY2hlbWFzKTtcbiAgICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7IHR5cGU6IG5hbWUsIHNjaGVtYTogbnVsbCwgdmFsaWRhdG9yIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gKiBiZSBgdW5kZWZpbmVkYC4gYGxvZ2Agd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGR5bmFtaWMgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICogcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB2YWxpZGF0ZSBpdCB3aXRoLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kZWxcbiAqIHZhbGlkYXRpb24gbG9naWMgdGhhdCBjaGFuZ2VzIGJhc2VkIG9uIGl0cyBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gZHluYW1pYyhmbikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHZhbGlkYXRpb24gaXMgcnVuIHdpdGggdGhlIHN0cnVjdCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gKiBjaXJjdWxhciBkZWZpbml0aW9uIHByb2JsZW0uXG4gKi9cbmZ1bmN0aW9uIGxhenkoZm4pIHtcbiAgICBsZXQgc3RydWN0O1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2xhenknLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBleGNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYE9taXRgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7IC4uLnNjaGVtYSB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgZGVsZXRlIHN1YnNjaGVtYVtrZXldO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUoc3Vic2NoZW1hKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IHdpdGggYWxsIG9mIGl0c1xuICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQYXJ0aWFsYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBwYXJ0aWFsKHN0cnVjdCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYSB9IDogeyAuLi5zdHJ1Y3QgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gICAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYW55KCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdiaWdpbnQnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5mdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2RhdGUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgdmFsaWQgXFxgRGF0ZVxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdlbnVtcycsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnZnVuYycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYCR7Q2xhc3MubmFtZX1cXGAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAncmVjb3JkJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5mdW5jdGlvbiB0eXBlKHNjaGVtYSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3R5cGUnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3VuaW9uJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlcnJvciwgY29lcmNlZF0gPSBTLnZhbGlkYXRlKHZhbHVlLCB7IGNvZXJjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqL1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG59XG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pXG4gICAgICAgICAgICAgICAgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpXG4gICAgICAgICAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXNQbGFpbk9iamVjdCh4KSAmJiBpc1BsYWluT2JqZWN0KGYpKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7IC4uLnggfTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCAoeCkgPT4geC50cmltKCkpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gKHNpemUgPT09IDAgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBlbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWF4KHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlIDw9IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGxlc3MgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1pbihzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA+IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA+PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBncmVhdGVyIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICovXG5mdW5jdGlvbiBub25lbXB0eShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChzaXplID4gMCB8fCBgRXhwZWN0ZWQgYSBub25lbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgYW4gZW1wdHkgb25lYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIChyZWdleHAudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IG1hdGNoaW5nIFxcYC8ke3JlZ2V4cC5zb3VyY2V9L1xcYCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5mdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXggPSBtaW4pIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YDtcbiAgICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gYG9mIFxcYCR7bWlufVxcYGAgOiBgYmV0d2VlbiBcXGAke21pbn1cXGAgYW5kIFxcYCR7bWF4fVxcYGA7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIHNpemUgJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBsZW5ndGggJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSByZWZpbmVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmVjZWl2ZSBhIHZhbHVlIG9mIHRoZSBzdHJ1Y3QncyB0eXBlLFxuICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICovXG5mdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cnVjdCwgU3RydWN0RXJyb3IsIGFueSwgYXJyYXksIGFzc2VydCwgYXNzaWduLCBiaWdpbnQsIGJvb2xlYW4sIGNvZXJjZSwgY3JlYXRlLCBkYXRlLCBkZWZhdWx0ZWQsIGRlZmluZSwgZGVwcmVjYXRlZCwgZHluYW1pYywgZW1wdHksIGVudW1zLCBmdW5jLCBpbnN0YW5jZSwgaW50ZWdlciwgaW50ZXJzZWN0aW9uLCBpcywgbGF6eSwgbGl0ZXJhbCwgbWFwLCBtYXNrLCBtYXgsIG1pbiwgbmV2ZXIsIG5vbmVtcHR5LCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QsIG9taXQsIG9wdGlvbmFsLCBwYXJ0aWFsLCBwYXR0ZXJuLCBwaWNrLCByZWNvcmQsIHJlZmluZSwgcmVnZXhwLCBzZXQsIHNpemUsIHN0cmluZywgc3RydWN0LCB0cmltbWVkLCB0dXBsZSwgdHlwZSwgdW5pb24sIHVua25vd24sIHZhbGlkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiU3RydWN0RXJyb3IiLCJUeXBlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImZhaWx1cmUiLCJmYWlsdXJlcyIsImNhY2hlZCIsIm1lc3NhZ2UiLCJleHBsYW5hdGlvbiIsInJlc3QiLCJwYXRoIiwibXNnIiwibGVuZ3RoIiwiam9pbiIsImNhdXNlIiwiT2JqZWN0IiwiYXNzaWduIiwibmFtZSIsImlzSXRlcmFibGUiLCJ4IiwiaXNPYmplY3QiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwiYnJhbmNoIiwidHlwZSIsInJlZmluZW1lbnQiLCJrZXkiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInNjaGVtYSIsIkFycmF5IiwiaXNBcnJheSIsInN0YXR1cyIsInZhbGlkYXRvciIsImsiLCJ2IiwicyIsImVudHJpZXMiLCJ0cyIsInQiLCJNYXAiLCJzZXQiLCJTZXQiLCJhZGQiLCJyZWZpbmVyIiwiU3RydWN0IiwicHJvcHMiLCJhc3NlcnQiLCJjcmVhdGUiLCJpcyIsInZhbGlkYXRlIiwidHVwbGVzIiwidHVwbGUiLCJlcnJvciIsIlN0cnVjdHMiLCJpc1R5cGUiLCJzY2hlbWFzIiwibWFwIiwib2JqZWN0IiwiZGVmaW5lIiwiZGVwcmVjYXRlZCIsImxvZyIsImR5bmFtaWMiLCJmbiIsImxhenkiLCJvbWl0Iiwia2V5cyIsInN1YnNjaGVtYSIsInBhcnRpYWwiLCJvcHRpb25hbCIsInBpY2siLCJjb25zb2xlIiwid2FybiIsImFueSIsImFycmF5IiwiRWxlbWVudCIsImkiLCJzbGljZSIsImJpZ2ludCIsImJvb2xlYW4iLCJkYXRlIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsImVudW1zIiwidmFsdWVzIiwiZGVzY3JpcHRpb24iLCJpbmNsdWRlcyIsImZ1bmMiLCJpbnN0YW5jZSIsIkNsYXNzIiwiaW50ZWdlciIsIk51bWJlciIsImlzSW50ZWdlciIsImludGVyc2VjdGlvbiIsIlMiLCJsaXRlcmFsIiwiY29uc3RhbnQiLCJLZXkiLCJWYWx1ZSIsIm5ldmVyIiwibnVsbGFibGUiLCJudW1iZXIiLCJrbm93bnMiLCJOZXZlciIsInVua25vd25zIiwiZGVsZXRlIiwicmVjb3JkIiwicmVnZXhwIiwiUmVnRXhwIiwic3RyaW5nIiwiTWF0aCIsIm1heCIsInVuaW9uIiwiY29lcmNlZCIsImZpcnN0IiwicHVzaCIsInVua25vd24iLCJjb25kaXRpb24iLCJkZWZhdWx0ZWQiLCJmYWxsYmFjayIsImYiLCJzdHJpY3QiLCJyZXQiLCJjaGFuZ2VkIiwidHJpbW1lZCIsInRyaW0iLCJlbXB0eSIsInJlZmluZSIsInNpemUiLCJnZXRTaXplIiwidGhyZXNob2xkIiwiZXhjbHVzaXZlIiwibWluIiwibm9uZW1wdHkiLCJwYXR0ZXJuIiwidGVzdCIsInNvdXJjZSIsImV4cGVjdGVkIiwib2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs\n");

/***/ })

};
;